<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Talleres Compuvisual</title><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/</link><description>Recent content on Talleres Compuvisual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jussilvaca.github.io/docs/talleres/shadersExercises/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/blendModes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/blendModes/</guid><description>Blend Modes (Operaciones con Colores) # Blend Modes es la manera en la que P5 mostrara la combinacion de dos colores.
Sketch de Blend (Multiplicacion) # Blend de dos colores haciendo uso de Shader (Multiplicacion) A traves del Fragment shader se realiza la operacion de \(rgb1 * rgb2\) blend.js let myShader; let c1, c2; function preload() { myShader = readShader(&amp;#39;/assets/shader/blend.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/nonEuclidean/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/nonEuclidean/</guid><description>Espacios No Euclideanos # Con la ayuda de los shader se busca representar objetos que burlar las conceptos geometricos basicos que estamos acustumbrados a ver en la realidad
Portal Shaders # Portal Shaders Dos Portales # Portal Shaders Con Múltiples reflejos # Referencias
https://visualcomputing.github.io/docs/shaders/non-euclidean_geometry/ https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/spatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/spatialCoherence/</guid><description>Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura.
Sketch Pixelator (Shader) # pixelator.js &amp;#39;use strict&amp;#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(&amp;#39;/assets/shader/pixelator.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(&amp;#39;/assets/image/slav_cheems.jpg&amp;#39;); img2 = loadImage(&amp;#39;/assets/image/dark_cheems.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/texturing/</guid><description>Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \(0 \leq X \leq 1\) y \(0 \leq Y \leq 1\) Sketch de UV Texturing # uv.</description></item></channel></rss>