<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Talleres Compuvisual</title><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/</link><description>Recent content on Talleres Compuvisual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jussilvaca.github.io/docs/talleres/shadersExercises/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/blendModes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/blendModes/</guid><description>Blend Modes (Operaciones con Colores) # Los Blend Modes o modos de fusión en la edición de imágenes digitales y los gráficos por computadora se utilizan para determinar cómo se fusionan dos capas entre sí. El modo de fusión predeterminado en la mayoría de las aplicaciones es simplemente oscurecer la capa inferior cubriéndola con lo que esté presente en la capa superior; Debido a que cada píxel tiene valores numéricos también hay muchas otras formas de combinar dos capas.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/nonEuclidean/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/nonEuclidean/</guid><description>Espacios No Euclideanos # Se denomina geometría no euclidiana a cualquier sistema formal de geometría cuyos postulados y proposiciones difieren en algún asunto de los establecidos por Euclides en su tratado Elementos. No existe un solo sistema de geometría no euclídea, sino muchos, aunque si se restringe la discusión a espacios homogéneos, en los que la curvatura del espacio es la misma en cada punto.
La geometría euclidiana satisface los cinco postulados de Euclides y tiene curvatura cero (es decir se supone en un espacio plano por lo que la suma de los tres ángulos interiores de un triángulo da siempre 180°).</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/portalShaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/portalShaders/</guid><description>Portal Shaders Dos Portales # Para esta etapa se propuso implementar correctamente 2 portales junto con su visualización y teletrasportación del personaje acorde a la posición y ángulo de entrada.
Se ubicó tanto el personaje como los dos portales en un espacio más controlado en donde se implementan las colisiones con paredes y algunos objetos como punto de referencia para el jugador.
Los shaders en esta ocasión funcionan correctamente para la visualización de la habitación y proyecciones planeadas.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/portalShadersMultipleReflejo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/portalShadersMultipleReflejo/</guid><description>Portal Shaders Con Múltiples reflejos # En esta última etapa se incorporan los dos objetivos faltantes en la etapa anterior.
Primero, se corrigen las colisiones y la cantidad de veces que puede entrar el personaje al portal.
Y por último, se adiciona dentro del portal los reflejos creados en el portal opuesto, de modo que dentro del portal se visualizan hasta 5 proyecciones de sí mismo para dar un efecto más realista y que acate los conceptos postulados por el juego original.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/spatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/spatialCoherence/</guid><description>Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura.
Sketch Pixelator (Shader) # pixelator.js &amp;#39;use strict&amp;#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(&amp;#39;/assets/shader/pixelator.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(&amp;#39;/assets/image/slav_cheems.jpg&amp;#39;); img2 = loadImage(&amp;#39;/assets/image/dark_cheems.</description></item><item><title/><link>https://jussilvaca.github.io/docs/talleres/shadersExercises/texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jussilvaca.github.io/docs/talleres/shadersExercises/texturing/</guid><description>Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \(0 \leq X \leq 1\) y \(0 \leq Y \leq 1\) Sketch de UV Texturing # uv.</description></item></channel></rss>