[{"id":0,"href":"/docs/talleres/ilusiones/","title":"Ilusiones","section":"Talleres","content":" Kernels de imagenes # Kernels de imagenes # Shortcuts Tecla Description F Cambiar mascara G Mostrar histograma H Cambiar imagen V Disminuir brillo B Aumentar brillo R Resetear imagen Ilusiones # Ver color en una imagen a blanco y negro # Nosotros tenemos tres tipos de conos en nuestros ojos, sensibles a las ondas de luz asociadas a los colores verde, rojo y azul. Cuando nos exponemos a una gran cantidad de luz de un determinado color, estos conos se fatigan y dejan de responder temporalmente. Cuando volvemos a ver la imagen en blanco y negro, solo actúan los conos que no están fatigados, por lo que vemos los colores complementarios a los \u0026ldquo;fatigados\u0026rdquo; durante unos segundos.\nShortcuts Tecla Description R Reiniciar el Timer O Mostrar Imagen Original Sube cualquier imagen Referencias\nhttps://verne.elpais.com/verne/2015/11/20/articulo/1448008967_394846.html\nFenómeno Phi (φ) # El término fenómeno phi se usa en un sentido estricto para un movimiento aparente que se observa si dos estímulos ópticos cercanos se presentan en alternancia con una frecuencia relativamente alta.\nSe aplica también a todos los movimientos aparentes que se pueden ver si se presentan alternativamente dos estímulos ópticos cercano.\nNacimiento de la psicología de Gestalt / Gestalismo / Configuracionismo # Los psicólogos de la Gestalt enfatizaron que los organismos perciben patrones o configuraciones completos, no solo componentes individuales. “El todo es más que la suma de sus partes”.\nReverse Phi Ilumination (φ) # Como el sistema visual humano percibe el movimiento phi aparente con dos estímulos ópticos estacionarios y similares presentados uno al lado del otro expuestos sucesivamente con alta frecuencia, también hay una versión inversa de este movimiento, que es la ilusión phi inversa. La ilusión phi inversa es el tipo de fenómeno phi que se desvanece o se disuelve de su dirección positiva a la negativa desplazada, de modo que el movimiento aparente que perciben los humanos es opuesto al desplazamiento físico real. La ilusión de phi inversa suele ir seguida de patrones en blanco y negro.\nSe cree que la ilusión de phi inversa es de hecho efectos de brillo, que ocurre cuando la imagen que invierte el brillo se mueve a través de nuestra retina. Puede explicarse por los mecanismos del modelo de campo receptivo visual, donde los estímulos visuales se suman espacialmente (un proceso que es inverso a la diferenciación espacial). Esta suma espacial desdibuja un poco el contorno y, por lo tanto, cambia el brillo percibido.\nShortcuts Tecla Description Espacio Mostrar regilla Slider V Ilusión - Desplazamiento vertical Slider H Ilusión - Desplazamiento horizontal Otro ejemplo # Referencias: https://michaelbach.de/ot/mot-reversePhi/index.html https://www.facebook.com/watch/?v=10158770212388374 https://www.muyinteresante.com.mx/cuerpo-mente/ilusiones-opticas-que-demuestra-lo-facil-que-es-enganar-al-cerebro-humano/ https://news.stanford.edu/pr/2011/pr-reverse-phi-motion-091211.html https://jov.arvojournals.org/article.aspx?articleid=2121864#133476828 Leaning Tower Illution # La ilusión de la torre inclinada es una ilusión visual que se ve en un par de imágenes idénticas de la Torre Inclinada de Pisa fotografiadas desde abajo. Aunque las imágenes son duplicadas, se tiene la impresión de que la torre de la derecha se inclina más, como si fuera fotografiada desde otro ángulo. La ilusión fue descubierta por Frederick Kingdom, Ali Yoonessi y Elena Gheorghiu en la Universidad McGill , y ganó el primer premio en el Concurso de Mejor Ilusión del Año 2007.\nLos autores sugieren que la ilusión se produce por la forma en que el sistema visual tiene en cuenta la perspectiva. Cuando dos torres idénticas se elevan en paralelo pero se ven desde abajo, sus contornos correspondientes convergen en la imagen retiniana debido a la perspectiva. El sistema visual normalmente \u0026ldquo;corrige\u0026rdquo; la distorsión de la perspectiva y, como resultado, percibe las torres correctamente, es decir, que se elevan en paralelo. Sin embargo, en el caso de las dos imágenes idénticas de la torre de Pisa, los contornos correspondientes de las torres no convergen sino que discurren en paralelo y, como resultado, las torres se perciben como no paralelas, es decir, divergentes.\nShortcuts Tecla Description Click Línea divisora Espacio Cambio de imagen Referencias: http://mesosyn.com/mental8-12.html https://en.wikipedia.org/wiki/Leaning_tower_illusion Jastrol Illution # La ilusión de Jastrow es una ilusión óptica descubierta por el psicólogo estadounidense Joseph Jastrow en 1889. A causa de esta ilusión se percibe como es de mayor tamaño la figura que está más abajo, cuando en realidad ambas tienen el mismo tamaño.\nShortcuts Tecla Description Click sostenido Mostrar tercera ficha Referencias: http://mesosyn.com/mental8-12.html https://en.wikipedia.org/wiki/Jastrow_illusion Poggendorff optical illusion # La ilusión de Poggendorff es un tipo de ilusión óptico-geométrica que implica la percepción errónea de la posición de la prolongación de un segmento inclinado al otro lado de un rectángulo oscuro que lo interrumpe. Debe su nombre a Johann Christian Poggendorff (editor de la revista que publicó las figuras ideadas por Johann Karl Friedrich Zöllner), quien la descubrió en 1860 al observar los dibujos que sirvieron para ilustrar la conocida actualmente como ilusión de Zöllner. La magnitud de la ilusión depende de la configuración del rectángulo que oculta el segmento y de la naturaleza de sus fronteras.\nimage.png\nMuchos estudios detallados de la ilusión, incluyendo la \u0026ldquo;amputación\u0026rdquo; de algunos de sus componentes,​ apuntan a su causa principal: los ángulos agudos en la figura son incorrectamente observados por los espectadores al ser extendidos mentalmente​ a través de la zona oscura, aunque la ilusión disminuye o desaparece cuando el segmento interrumpido es horizontal o vertical. Se sabe que otros factores también están implicados en esta ilusión.​\nShortcuts Tecla Description Slider Opacidad del rectángulo Referencias: http://mesosyn.com/mental8-3.html https://es.wikipedia.org/wiki/Ilusi%C3%B3n_de_Poggendorff http://www.abc-people.com/illusion/illusion-4.htm https://www.newworldencyclopedia.org/entry/Poggendorff_illusion Ejercicios # Exercise\nLet rgb1 and rgb2 be two rgb colors. What rgb1 * rgb2 would mean?\nSabemos que los colores en formato RGB están representados por valores de 0 a 255 en cada uno de los canales (R=Red, G=Green, B=Blue), al ser valores numéricos que implicación su multiplicación.\nPara realizar la multiplicacion de valores de RGB estos primero son normalizados a valores entre 0 a 1, por ejemplo un amarillo (255,255,0) en su forma normalizada seria (1,1,0), para operarlo con otro color como el azul cyan (0, 255, 255), su forma normalizada es (0,1,1), al multiplicar estos colores componente a componente.\n(1, 1, 0)*(0, 1, 1)= (1 * 0, 1 * 1, 0 * 1 )\nDe aqui obtendriamos el color verde que seria (0,1,0) , es decir (0, 255,0)\n"},{"id":1,"href":"/docs/talleres/portal/","title":"Portal","section":"Talleres","content":" Portal # Sketch de Portal # Aqui va el sketch de Portal\n"},{"id":2,"href":"/docs/talleres/shadersExercises/","title":"Shaders Exercises","section":"Talleres","content":" Shaders # ¿Qué es un shader? # Un shader es un programa que se ejecuta en la GPU del ordenador, y genera la salida visual en pantalla dada la información que define una escena 2D o 3D: vértices, colores, texturas, luces, etc. Los shaders no sólo sirven para calcular los niveles de sombreado o iluminación de la escena, sino que son los responsables de todas las etapas del renderizado: desde las transformaciones de la cámara que se aplican sobre la geometría en bruto, hasta la evaluación del color final de cada píxel visible en pantalla.\nPara hacer uso de los shaders es necesario tener el canvas en el modo WEBGL\nEjercicios # Blend Modes Blend Modes (Operaciones con Colores) # Los Blend Modes o modos de fusión en la edición de imágenes digitales y los gráficos por computadora se utilizan para determinar cómo se fusionan dos capas entre sí. El modo de fusión predeterminado en la mayoría de las aplicaciones es simplemente oscurecer la capa inferior cubriéndola con lo que esté presente en la capa superior; Debido a que cada píxel tiene valores numéricos también hay muchas otras formas de combinar dos capas. Non Euclidean Espacios No Euclideanos # Se denomina geometría no euclidiana a cualquier sistema formal de geometría cuyos postulados y proposiciones difieren en algún asunto de los establecidos por Euclides en su tratado Elementos. No existe un solo sistema de geometría no euclídea, sino muchos, aunque si se restringe la discusión a espacios homogéneos, en los que la curvatura del espacio es la misma en cada punto. La geometría euclidiana satisface los cinco postulados de Euclides y tiene curvatura cero (es decir se supone en un espacio plano por lo que la suma de los tres ángulos interiores de un triángulo da siempre 180°). Portal Shaders Portal Shaders Dos Portales # Para esta etapa se propuso implementar correctamente 2 portales junto con su visualización y teletrasportación del personaje acorde a la posición y ángulo de entrada. Se ubicó tanto el personaje como los dos portales en un espacio más controlado en donde se implementan las colisiones con paredes y algunos objetos como punto de referencia para el jugador. Los shaders en esta ocasión funcionan correctamente para la visualización de la habitación y proyecciones planeadas. Spatial Coherence Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura. Sketch Pixelator (Shader) # pixelator.js \u0026#39;use strict\u0026#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(\u0026#39;/assets/shader/pixelator.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems. Texturing Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \\(0 \\leq X \\leq 1\\) y \\(0 \\leq Y \\leq 1\\) Sketch de UV Texturing # uv. "},{"id":3,"href":"/docs/talleres/shadersExercises/blendModes/","title":"Blend Modes","section":"Shaders Exercises","content":" Blend Modes (Operaciones con Colores) # Los Blend Modes o modos de fusión en la edición de imágenes digitales y los gráficos por computadora se utilizan para determinar cómo se fusionan dos capas entre sí. El modo de fusión predeterminado en la mayoría de las aplicaciones es simplemente oscurecer la capa inferior cubriéndola con lo que esté presente en la capa superior; Debido a que cada píxel tiene valores numéricos también hay muchas otras formas de combinar dos capas.\nLa mayoría de los programas de edición de gráficos como Adobe Photoshop y GIMP permiten a los usuarios modificar los modos de fusión básicos, por ejemplo, aplicando diferentes niveles de opacidad a la \u0026ldquo;capa superior\u0026rdquo;.\nBlend Modes es la manera en la que P5 mostrara la combinacion de dos colores.\nSketch de Blend (Multiplicacion) # Blend de dos colores haciendo uso de Shader (Multiplicacion) A traves del Fragment shader se realiza la operacion de \\(rgb1 * rgb2\\) blend.js let myShader; let c1, c2; function preload() { myShader = readShader(\u0026#39;/assets/shader/blend.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); shader(myShader); } function draw() { background(0); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } blend.frag precision mediump float; // uniforms are emitted from the sketch // https://p5js.org/reference/#/p5.Shader/setUniform uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 * uMaterial2; } Sketch Blend con Brillo (Multiplicacion) # Blend de dos colores haciendo uso de Shader con valor de brillo (Multiplicacion)\nA traves del Fragment shader se realiza la operacion de \\(brillo * rgb1 * rgb2\\) blendBright.js let myShader; let c1, c2, brightBar; function preload() { myShader = readShader(\u0026#39;/assets/shader/blendBright.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); brightBar = createSlider(0, 1, 0.5, 0.05); brightBar.position(width / 2 - 35, height / 2); brightBar.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); shader(myShader); } function draw() { background(0); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, 1.0); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, 1.0); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, brightBar.value()); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } blendBright.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = brightness * uMaterial1 * uMaterial2; } Sketch Blend AllModes # Algunos ejemplos de Blend tomando como base dos colores haciendo uso de Shader.\nBlend Add # Este modo de blend suma los valores de los pixeles de una capa con otra. En el caso en que los valores sean superiores a \\( 1 \\) (En el caso de RGB) éste se mostrará en blanco.\nblendAdd.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 + uMaterial2; } Blend Substract # Este modo de blend resta los valores de píxeles de una capa con la otra. En caso de valores negativos, se muestra en negro.\nblendSubstract.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 - uMaterial2; } Blend Divide # Este blend divide los valores de píxeles de una capa con la otra. Es útil para iluminar imágenes en especial con colores grisáceos.\nTambién es útil para eliminar tintes de color, ya que considerando que cualquier valor dividido por sí mismo es igual a \\( 1.0 \\) , es decir, blanco.\nblendDivide.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 / uMaterial2; } Blend Screen # En este modo de blend los valores de los pixeles en las dos capas se invierten, se multiplican y posteriormente se vuelven a invertir. El resultado es opuesto al blend de multiplicación y como resultado se tendrá un color más brillante (siempre que una de las capas sea más oscura que blanco)\n\\( f(a,b) = 1 - (1 - a)(1 - b) \\) Donde \\( a\\) es la capa base y \\( b\\) es la capa superior.\nEste tipo de blend tiene un resultado conmutativo.\nblendScreen.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = vec4(1.0) - (vec4(1.0)- uMaterial1) * (vec4(1.0) - uMaterial2); } Blend Overlay # El Overlay Blend es una combinación de Multiply blend y Screen blend. En donde: si la capa base es clara, la capa superior se vuelve más clara; si la capa base es oscura, la capa superior se vuelve más oscura; y no se ve afectada la capa superior si la capa base es gris.\n\\( f(a,b)= \\left\\{ \\begin{array}{lcc} 2ab, \u0026amp; si \u0026amp; a \u0026lt; 0.5 \\\\ \\\\ 1 - 2(1 - a)(1 - b), \u0026amp; si \u0026amp; x \\geq 0,5 \\\\ \\end{array} \\right.\\) Donde \\( a\\) es la capa base y \\( b\\) es la capa superior\nblendOverlay.frag precision mediump float; // uniforms are emitted from the sketch // https://p5js.org/reference/#/p5.Shader/setUniform uniform vec4 uMaterial1; uniform vec4 uMaterial2; float rChannel; float gChannel; float bChannel; void main () { // gl_FragColor is a special variable that defines the color of the pixel // https://p5js.org/reference/#/p5.Shader/setUniform if (uMaterial1.x \u0026lt;= 0.5) { rChannel = 2.0*uMaterial1.x*uMaterial2.x; }else{ rChannel = 1.0 - 2.0*(1.0-uMaterial1.x)*(1.0-uMaterial2.x); } if(uMaterial1.y \u0026lt;= 0.5){ gChannel = 2.0*uMaterial1.y*uMaterial2.y; }else{ gChannel = 1.0 - 2.0*(1.0-uMaterial1.y)*(1.0-uMaterial2.y); } if(uMaterial1.z \u0026lt;= 0.5){ bChannel = 2.0*uMaterial1.z*uMaterial2.z; }else{ bChannel = 1.0 - 2.0*(1.0-uMaterial1.z)*(1.0-uMaterial2.z); } gl_FragColor = vec4(rChannel, gChannel, bChannel, 1.0); } Blend SoftLight # Está muy relacionado con Overlay blend y hay múltiples maneras de aplicarlo, en este caso se utiliza la fórmula :\n\\( f_{pegtop}(a,b) = (1 - 2b)a² \u0026#43; 2ba\\) que es una interpolación lineal Multiply blend (para \\( a = 0\\) ) y Screen Blend ( para \\( a = 1 \\) ).\nblendSoftLight.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = (vec4(1.0)-2.0*uMaterial2)*(uMaterial1*uMaterial1)+2.0*uMaterial2*uMaterial1; } Blend Darkness # Sólo se toman los valores de los colores más oscuros, de modo que:\n\\( C = min(A*factor,B) \\) blendDarkness.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = min(uMaterial1, uMaterial2); } Blend Lighten # Sólo se toman los valores de los colores más claros, de modo que:\n\\( C = max(A*factor,B) \\) blendLighten.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = max(uMaterial1, uMaterial2); } blendAllModes.js let AddShader, SubstractShader, DivideShader, ScreenShader, OverlayShader, SoftLightShader, DarknessShader, LightenShader; let c1, c2; let mode; function preload() { AddShader = readShader(\u0026#39;/assets/shader/blendAdd.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); SubstractShader = readShader(\u0026#39;/assets/shader/blendSubstract.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); DivideShader = readShader(\u0026#39;/assets/shader/blendDivide.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); ScreenShader = readShader(\u0026#39;/assets/shader/blendScreen.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); OverlayShader = readShader(\u0026#39;/assets/shader/blendOverlay.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); SoftLightShader = readShader(\u0026#39;/assets/shader/blendSoftLight.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); DarknessShader = readShader(\u0026#39;/assets/shader/blendDarkness.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); LightenShader = readShader(\u0026#39;/assets/shader/blendLighten.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); mode = createSelect(); mode.position(10, 40); mode.option(\u0026#39;AddShader\u0026#39;); mode.option(\u0026#39;SubstractShader\u0026#39;); mode.option(\u0026#39;DivideShader\u0026#39;); mode.option(\u0026#39;ScreenShader\u0026#39;); mode.option(\u0026#39;OverlayShader\u0026#39;); mode.option(\u0026#39;SoftLightShader\u0026#39;); mode.option(\u0026#39;DarknessShader\u0026#39;); mode.option(\u0026#39;LightenShader\u0026#39;); mode.selected(\u0026#39;AddShader\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadAShader(mode.value()); } function loadAShader(value) { if (value == \u0026#39;AddShader\u0026#39;) { resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if (value == \u0026#39;SubstractShader\u0026#39;) { resetShader(); shader(SubstractShader); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [-red(c2.color()), -green(c2.color()), -blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;DivideShader\u0026#39;){ resetShader(); shader(DivideShader); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c2.color())**2, green(c2.color())**2, blue(c2.color())**2, 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;ScreenShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(ScreenShader); ScreenShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); ScreenShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;OverlayShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(OverlayShader); OverlayShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); OverlayShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;SoftLightShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(SoftLightShader); SoftLightShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SoftLightShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;DarknessShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(DarknessShader); DarknessShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DarknessShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;LightenShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(LightenShader); LightenShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); LightenShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } } Referencias\nhttps://en.wikipedia.org/wiki/Blend_modes https://p5js.org/reference/#/p5/blendMode https://visualcomputing.github.io/docs/shaders/coloring/\n"},{"id":4,"href":"/docs/talleres/shadersExercises/nonEuclidean/","title":"Non Euclidean","section":"Shaders Exercises","content":" Espacios No Euclideanos # Se denomina geometría no euclidiana a cualquier sistema formal de geometría cuyos postulados y proposiciones difieren en algún asunto de los establecidos por Euclides en su tratado Elementos. No existe un solo sistema de geometría no euclídea, sino muchos, aunque si se restringe la discusión a espacios homogéneos, en los que la curvatura del espacio es la misma en cada punto.\nLa geometría euclidiana satisface los cinco postulados de Euclides y tiene curvatura cero (es decir se supone en un espacio plano por lo que la suma de los tres ángulos interiores de un triángulo da siempre 180°).\nCon la ayuda de los shaders en este punto se buscó representar objetos y espacios que de alguna manera burlen los conceptos geométricos básicos a los que estamos acostumbrados. Distorcionando así nuestra visión de la realidad .\nEjemplo base # Para ejecutar esta sección primero se tomó como base la actividad sugerida por el docente, identificando y completando el cubo con los shaders para formar espacios que no corresponden a un espacio euclidiano.\nnonEuclidean.js let easycam; let edge = 80; let teapot, bunny, dog, fox, cow, cup; let teapotTex, bunnyTex, dogTex, foxTex, cowTex, cupTex; let texShader; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(\u0026#39;/assets/shader/non_euclidean.frag\u0026#39;, { varyings: Tree.NONE }); teapot = loadModel(\u0026#39;/assets/models/teapot.obj\u0026#39;, true); bunny = loadModel(\u0026#39;/assets/models/bunny.obj\u0026#39;, true); dog = loadModel(\u0026#39;/assets/models/dog.obj\u0026#39;, true); fox = loadModel(\u0026#39;/assets/models/fox.obj\u0026#39;, true); cow = loadModel(\u0026#39;/assets/models/cow.obj\u0026#39;, true); cup = loadModel(\u0026#39;/assets/models/cup.obj\u0026#39;, true); } function setup() { createCanvas(600, 600, WEBGL); // no need to normalize the texture // textureMode(NORMAL); shader(texShader); // resolution will be used to sample the offscreen textures emitResolution(texShader); easycam = createEasyCam(); teapotTex = createGraphics(width, height, WEBGL); bunnyTex = createGraphics(width, height, WEBGL); dogTex = createGraphics(width, height, WEBGL); foxTex = createGraphics(width, height, WEBGL); cowTex = createGraphics(width, height, WEBGL); cupTex = createGraphics(width, height, WEBGL); } function draw() { // 1. compute current main canvas camera params let position = treeLocation(); let center = p5.Vector.add(position, treeDisplacement()); let up = treeDisplacement(Tree.j); // in case the current camera projection params are needed check: // https://github.com/VisualComputing/p5.treegl#frustum-queries // 2. offscreen rendering // bunny graphics bunnyTex.background(200); bunnyTex.reset(); bunnyTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); bunnyTex.push(); bunnyTex.noStroke(); bunnyTex.fill(\u0026#39;red\u0026#39;); // most models use positive y-coordinates bunnyTex.scale(1, -1); bunnyTex.scale(0.8);// only bunny bunnyTex.model(bunny); bunnyTex.pop(); // teapot graphics teapotTex.background(200); teapotTex.reset(); teapotTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); teapotTex.push(); teapotTex.noStroke(); teapotTex.fill(\u0026#39;blue\u0026#39;); teapotTex.scale(1, -1); teapotTex.model(teapot); teapotTex.pop(); // dog graphics dogTex.background(200); dogTex.reset(); dogTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); dogTex.push(); dogTex.noStroke(); dogTex.fill(\u0026#39;green\u0026#39;); dogTex.scale(1, -1); dogTex.model(dog); dogTex.pop(); // fox graphics foxTex.background(200); foxTex.reset(); foxTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); foxTex.push(); foxTex.noStroke(); foxTex.fill(\u0026#39;yellow\u0026#39;); foxTex.scale(1, -1); foxTex.model(fox); foxTex.pop(); // cow graphics cowTex.background(200); cowTex.reset(); cowTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); cowTex.push(); cowTex.noStroke(); cowTex.fill(\u0026#39;orange\u0026#39;); cowTex.scale(1, -1); cowTex.model(cow); cowTex.pop(); // cup graphics cupTex.background(200); cupTex.reset(); cupTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); cupTex.push(); cupTex.noStroke(); cupTex.fill(\u0026#39;purple\u0026#39;); cupTex.scale(1, -1); cupTex.model(cup); cupTex.pop(); // 3. main canvas background(0); push(); // front (+z) stroke(\u0026#39;purple\u0026#39;); strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, bunnyTex); beginShape(); vertex(-edge, -edge, +edge); vertex(+edge, -edge, +edge); vertex(+edge, +edge, +edge); vertex(-edge, +edge, +edge); endShape(CLOSE); // right (+x) texShader.setUniform(\u0026#39;texture\u0026#39;, teapotTex); beginShape(); vertex(+edge, -edge, +edge); vertex(+edge, -edge, -edge); vertex(+edge, +edge, -edge); vertex(+edge, +edge, +edge); endShape(CLOSE); // left (-x) texShader.setUniform(\u0026#39;texture\u0026#39;, dogTex); beginShape(); vertex(-edge, -edge, -edge); vertex(-edge, -edge, +edge); vertex(-edge, +edge, +edge); vertex(-edge, +edge, -edge); endShape(CLOSE); // back (-z) texShader.setUniform(\u0026#39;texture\u0026#39;, foxTex); beginShape(); vertex(+edge, -edge, -edge); vertex(-edge, -edge, -edge); vertex(-edge, +edge, -edge); vertex(+edge, +edge, -edge); endShape(CLOSE); // top (+y) texShader.setUniform(\u0026#39;texture\u0026#39;, cowTex); beginShape(); vertex(-edge, +edge, +edge); vertex(+edge, +edge, +edge); vertex(+edge, +edge, -edge); vertex(-edge, +edge, -edge); endShape(CLOSE); // bottom (-y) texShader.setUniform(\u0026#39;texture\u0026#39;, cupTex); beginShape(); vertex(-edge, -edge, -edge); vertex(+edge, -edge, -edge); vertex(+edge, -edge, +edge); vertex(-edge, -edge, +edge); endShape(CLOSE); pop(); } Portal Shaders # Como segundo paso se buscó implementar los shaders en el para el desarrollo de los conceptos inspirados por el juego de \u0026ldquo;Portal\u0026rdquo;, consiguiéndo así esta primera versión.\nEn esta etapa podemos ver un portal en la mitad de la escena, si bien a primera vista éste portal puede parecer simplemente un arco hueco, al mover la cámara y ubicarla en la parte trasera nos damos cuenta que es una figura circular sólida.\nEn esta figura se proyecta un shader que nos permite, a modo de puerta, visualizar lo que está detrás del portal.\nportalShaderV1.js let press = 0; let changeCam = 0; let angle = 0; let kemonaSilver; let player1, playerOnPortal1; let fbo1, fbo1TextPort1; let portalShader; // obj models let fox; let cat1; let cat2; // texture of models let fox_tex; let cat1_tex; let cat2_tex; let edge = 80; let cam1, cam2, cam3; let cam3Pos, cam4Pos; let onCam1 = true, onCam2 = false; let dummy; function preload() { kemonaSilver = loadImage(\u0026#39;/assets/image/KemonaPlushSilver.jpg\u0026#39;); fox_tex = loadImage(\u0026#39;/assets/models/fox.png\u0026#39;); fox = loadModel(\u0026#39;/assets/models/fox.obj\u0026#39;, true); cat1_tex = loadImage(\u0026#39;/assets/models/cat_plush_01.png\u0026#39;); cat1 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); cat2_tex = loadImage(\u0026#39;/assets/models/cat_plush_02.png\u0026#39;); cat2 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); portalShader = readShader(\u0026#39;/assets/shader/portal.frag\u0026#39;, { varyings: Tree.NONE }); } function setup() { createCanvas(900, 900, WEBGL); dummy = createGraphics(1, 1, WEBGL); fbo1 = createGraphics(900, 900, WEBGL); fbo1TextPort1 = createGraphics(900, 900, WEBGL); player1 = new Player(0, 0, 600); playerOnPortal1 = new Player(0, 0, 0); portal1Onfbo1 = new Portal(0, 0, edge+80, 0); portal2Onfbo1 = new Portal(0, 0, 0, 0); portal1Onfbo1.link(portal2Onfbo1); cam1 = fbo1.createCamera(); // firts person camera cam2 = new Dw.EasyCam(fbo1._renderer, { distance: 848.5208406737183, // scalar (optional) center: [0, 0, 0], // vector (optional) rotation: [0.9686568165691878, -0.24785495689905887, -0.014390494259618537, -0.008050200592452867], // quaternion (optional) }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([0, 0, 900, 900]); cam3 = fbo1TextPort1.createCamera(); // camera on portal 1 } function draw() { // 1. compute current main canvas camera params let position = fbo1.treeLocation(); let center = p5.Vector.add(position, fbo1.treeDisplacement()); let up = fbo1.treeDisplacement(Tree.j); fbo1TextPort1.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); // 2. set scenes scene(fbo1); scene(fbo1TextPort1); player1.movement(); player1.render(fbo1); if (player1.playerPos != 0) { playerOnPortal1.pos = player1.pos playerOnPortal1.a = player1.a playerOnPortal1.render(fbo1TextPort1); } portal1Onfbo1.render(fbo1, 0, fbo1TextPort1, portalShader); let camCoor = camFovCoordinates(-900, player1.pos, -player1.a, -60, 40); cam1.camera(camCoor.xp, camCoor.yp, camCoor.zp, camCoor.xc, camCoor.yc, camCoor.zc, camCoor.xn, camCoor.yn, camCoor.zn) if (changeCam) { if (onCam1) { cam2.setCanvas(dummy._renderer); fbo1.setCamera(cam1) onCam1 = false; onCam2 = true; } else { if (onCam2) { fbo1.reset(); cam2.setCanvas(fbo1._renderer); onCam1 = true; onCam2 = false; } } changeCam = 0; } if (press) { console.log({ x: player1.pos.x, y: player1.pos.y, z: player1.pos.z }); console.log({ angle: player1.a }); let v = p5.Vector.fromAngle(player1.a); console.log({ x: v.x, y: v.y, z: v.z }); press = 0; } beginHUD(); image(fbo1, 0, 0); endHUD(); } class Player { constructor(x, y, z) { this.pos = createVector(x, y, z); this.prevPos = this.pos.copy(); this.a = 0; this.speed = 3; this.aspeed = PI / 90; this.playerPos = this.pos; this.playerDis = 0; } move(fw) { this.prevPos.set(this.pos); const vel = p5.Vector.fromAngle(this.a); if (fw) { vel.mult(this.speed); this.pos.add(-vel.x, 0, vel.y); } else { vel.mult(this.speed); this.pos.add(vel.x, 0, -vel.y); } if (this.pos.x \u0026gt; 600) { this.pos.x = 600 } if (this.pos.z \u0026gt; 600) { this.pos.z = 600 } if (this.pos.x \u0026lt; -600) { this.pos.x = -600 } if (this.pos.z \u0026lt; -610) { this.pos.z = -610 } } movement() { if (keyIsDown(65)) this.turn(1); if (keyIsDown(68)) this.turn(-1); if (keyIsDown(87)) this.move(true); if (keyIsDown(83)) this.move(false); } turn(dir) { this.a += dir * this.aspeed; } render(fbo) { fbo.push(); fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.noStroke(); fbo.push(); fbo.rotateZ(PI); fbo.rotateY(HALF_PI); fbo.texture(fox_tex); fbo.model(fox); fbo.pop(); fbo.pop(); } } class Portal { constructor(x, y, z, a) { this.pos = createVector(x, y, z); this.len = 220; this.a = a; this.portalPos = 0; this.linkedPortal = null; } link(other) { this.linkedPortal = other; other.linkedPortal = this; } check_(player) { const relativePos = player.playerPos.copy(); relativePos.sub(this.portalPos); relativePos.rotate(-this.a); const relativePrevPos = player.prevPos.copy(); relativePrevPos.sub(this.portalPos); relativePrevPos.rotate(-this.a); if ((relativePos.z \u0026lt; 28) !== (relativePrevPos.z \u0026lt; 28) \u0026amp;\u0026amp; abs(relativePos.x) \u0026lt; this.len / 2) { console.log(\u0026#34;Teletransportado\u0026#34;); player.a += this.linkedPortal.a - this.a; return true; } return false; } check(player) { return this.check_(player); } render(fbo, numberPortal, texElement, portalShader) { fbo.push() fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.push() fbo.translate(0, 0, -1); if (numberPortal === 0) { fbo.fill(0, 0, 255) } else { fbo.fill(255, 158, 0) } fbo.circle(0, 0, 260) fbo.pop() if (portalShader) { fbo.shader(portalShader); fbo.emitResolution(portalShader); portalShader.setUniform(\u0026#39;texture\u0026#39;, texElement); } else { if (texElement) { fbo.texture(texElement); } } fbo.circle(0, 0, 250) this.portalPos = fbo.treeLocation(/*[0, 0, 0],*/ { from: Tree.MODEL, to: Tree.WORLD }); fbo.pop() } } function scene(fbo) { fbo.background(120); fbo.reset(); fbo.rectMode(CENTER); fbo.noStroke(); fbo.push(); fbo.ambientLight(255); fbo.push(); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(kemonaSilver) fbo.box(100) fbo.pop(); fbo.push(); fbo.translate(-350, 0, -350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat1_tex) fbo.model(cat1); fbo.pop(); fbo.push(); fbo.translate(350, 0, 350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat2_tex) fbo.model(cat2); fbo.pop(); fbo.push(); fbo.noStroke(); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, 100); fbo.rotateX(HALF_PI); fbo.plane(1200, 1200); fbo.pop(); fbo.pop(); } function keyPressed() { if (keyCode === 67) { if (changeCam === 0) { changeCam = 1; } } if (keyCode === 73) { if (press === 0) { press = 1; } } } function camFovCoordinates(radio, posVec, angle, hy, chy) { let vecAngle = p5.Vector.fromAngle(angle); let radioCam = -10; return { xp: (posVec.x + (radioCam * vecAngle.x)), yp: posVec.y + hy, zp: (posVec.z + (radioCam * vecAngle.y)), xc: (posVec.x + (radio * vecAngle.x)), yc: posVec.y + chy, zc: (posVec.z + (radio * vecAngle.y)), xn: 0, yn: 1, zn: 0 }; } Comandos Tecla Descripción W Mover hacia adelante A Girar hacia la izquierda D Girar hacia la derecha S Mover hacia atrás C Cambiar vista primera/tercera persona Continuar en Portal con shaders # Referencias\nhttps://visualcomputing.github.io/docs/shaders/non-euclidean_geometry/ https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana\n"},{"id":5,"href":"/docs/talleres/shadersExercises/portalShaders/","title":"Portal Shaders","section":"Shaders Exercises","content":" Portal Shaders Dos Portales # Para esta etapa se propuso implementar correctamente 2 portales junto con su visualización y teletrasportación del personaje acorde a la posición y ángulo de entrada.\nSe ubicó tanto el personaje como los dos portales en un espacio más controlado en donde se implementan las colisiones con paredes y algunos objetos como punto de referencia para el jugador.\nLos shaders en esta ocasión funcionan correctamente para la visualización de la habitación y proyecciones planeadas.\nPara esta etapa del proyecto restan hacer dos correcciones importantes: 1) Corregir la cantidad de teletrasportaciones (entradas al portal). 2) Que en el portal se visualice a su vez el otro portal y sus reflejos (Como cuando se enfrenta un espejo frente a otro).\nportalShaderV2.js let press = 0; // variable get info funcions let changeCam = 0; //variable that indicate the position of the camera let angle = 0; // angle of rotation of some objects let kemonaSilver; let player1, playerOnPortal1, playerOnPortal2; let fbo1, fbo1TextPort1, fbo1TextPort2; let portalShader; let portal1Onfbo1, portal2Onfbo1; // obj models let fox; let cat1; let cat2; // texture of models let fox_tex; let cat1_tex; let cat2_tex; let set1 = 0, set2 = 0; let starCheck1 = 0, starCheck2 = 0, restart = 0; let teleportedFbo1 = false, teleportedFbo2 = false; let cam1, cam2, cam3, cam4; let cam3Pos, cam4Pos; let onCam1 = true, onCam2 = false; let dummy; function preload() { kemonaSilver = loadImage(\u0026#39;/assets/image/KemonaPlushSilver.jpg\u0026#39;); fox_tex = loadImage(\u0026#39;/assets/models/fox.png\u0026#39;); fox = loadModel(\u0026#39;/assets/models/fox.obj\u0026#39;, true); cat1_tex = loadImage(\u0026#39;/assets/models/cat_plush_01.png\u0026#39;); cat1 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); cat2_tex = loadImage(\u0026#39;/assets/models/cat_plush_02.png\u0026#39;); cat2 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); portalShader = readShader(\u0026#39;/assets/shader/portal.frag\u0026#39;, { varyings: Tree.NONE }); } function setup() { createCanvas(900, 900, WEBGL); dummy = createGraphics(1, 1, WEBGL); fbo1 = createGraphics(900, 900, WEBGL); fbo2 = createGraphics(900, 900, WEBGL); fbo1TextPort1 = createGraphics(900, 900, WEBGL); fbo1TextPort2 = createGraphics(900, 900, WEBGL); player1 = new Player(0, 0, 100); playerOnPortal1 = new Player(0, 0, 0); playerOnPortal2 = new Player(0, 0, 0); portal1Onfbo1 = new Portal(0, 0, -437, 0); portal2Onfbo1 = new Portal(0, 0, 437, PI); portal2Onfbo1.link(portal1Onfbo1); cam1 = fbo1.createCamera(); // firts person camera cam2 = new Dw.EasyCam(fbo1._renderer, { distance: 848.5208406737183, // scalar (optional) center: [0, 0, 0], // vector (optional) rotation: [0.9686568165691878, -0.24785495689905887, -0.014390494259618537, -0.008050200592452867], // quaternion (optional) }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([0, 0, 900, 900]); cam3 = fbo1TextPort1.createCamera(); // camera on portal 1 cam4 = fbo1TextPort2.createCamera(); // camera on portal 2 } function draw() { // 1. compute current main canvas camera params let position = fbo1.treeLocation(); let center = p5.Vector.add(position, fbo1.treeDisplacement()); let up = fbo1.treeDisplacement(Tree.j); fbo1TextPort1.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); let position1 = fbo1.treeLocation(); let center1 = p5.Vector.add(position1, fbo1.treeDisplacement()); let up1 = fbo1.treeDisplacement(Tree.j); fbo1TextPort2.camera(position1.x, position1.y, position1.z, center1.x, center1.y, center1.z, up1.x, up1.y, up1.z); // 2. set scenes scene(fbo1, 0, 0, 1, 1); scene(fbo1TextPort1, 1, 0, 0, 1); scene(fbo1TextPort2, 0, 1, 1, 0); if (teleportedFbo1 \u0026amp;\u0026amp; !teleportedFbo2) { player1.movement(); player1.render(fbo1); restart = 1; // if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { // starCheck1 = 1; // } // if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { // starCheck2 = 1; // } // if (starCheck1) { // teleportedFbo1 = portal1Onfbo1.check(player1) // } // if (starCheck2) { // teleportedFbo2 = portal2Onfbo1.check(player1) // console.log(\u0026#34;SSSSSSSSSS\u0026#34;); // } } if (!teleportedFbo1 \u0026amp;\u0026amp; teleportedFbo2) { player1.movement(); player1.render(fbo1); restart = 1; // console.log(\u0026#34;KLAJSHKJALHDAD\u0026#34;); // if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { // starCheck1 = 1; // } // if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { // starCheck2 = 1; // } // // if (starCheck1) { // // teleportedFbo1 = portal1Onfbo1.check(player1) // // } // // if (starCheck2) { // // teleportedFbo2 = portal2Onfbo1.check(player1) // // } } if (restart) { set1 = 0; set2 = 0; starCheck1 = 0; starCheck2 = 0; teleportedFbo1 = false; teleportedFbo2 = false; restart = 0; } if ((!teleportedFbo1 \u0026amp;\u0026amp; !teleportedFbo2)) { player1.movement(); player1.render(fbo1); if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { starCheck1 = 1; } if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { starCheck2 = 1; } if (starCheck1) { teleportedFbo1 = portal1Onfbo1.check(player1) } if (starCheck2) { teleportedFbo2 = portal2Onfbo1.check(player1) } if (teleportedFbo1) { set1 = 1; console.log(\u0026#34;teleportedFbo1\u0026#34;); } if (teleportedFbo2) { set2 = 1; console.log(\u0026#34;teleportedFbo2\u0026#34;); } if (set1) { player1.pos = portal2Onfbo1.portalPos set1 = 0; } if (set2) { player1.pos = portal1Onfbo1.portalPos set2 = 0; } } if (player1.playerPos != 0) { playerOnPortal1.pos = player1.pos playerOnPortal1.a = player1.a playerOnPortal1.render(fbo1TextPort1, 1, 0); playerOnPortal2.pos = player1.pos playerOnPortal2.a = player1.a playerOnPortal2.render(fbo1TextPort2, 0, 1); } angle += 0.007 portal1Onfbo1.render(fbo1, 0, fbo1TextPort1, portalShader); portal2Onfbo1.render(fbo1, 1, fbo1TextPort2, portalShader); let camCoor = camFovCoordinates(-900, player1.pos, -player1.a, -60, 40); cam1.camera(camCoor.xp, camCoor.yp, camCoor.zp, camCoor.xc, camCoor.yc, camCoor.zc, camCoor.xn, camCoor.yn, camCoor.zn) if (changeCam) { if (onCam1) { cam2.setCanvas(dummy._renderer); fbo1.setCamera(cam1) onCam1 = false; onCam2 = true; } else { if (onCam2) { fbo1.reset(); cam2.setCanvas(fbo1._renderer); onCam1 = true; onCam2 = false; } } changeCam = 0; } if (press) { console.log({ x: player1.pos.x, y: player1.pos.y, z: player1.pos.z }); console.log({ angle: player1.a }); let v = p5.Vector.fromAngle(player1.a); console.log({ x: v.x, y: v.y, z: v.z }); press = 0; } beginHUD(); image(fbo1, 0, 0); endHUD(); } class Player { constructor(x, y, z) { this.pos = createVector(x, y, z); this.prevPos = this.pos.copy(); this.a = 0; this.speed = 3; this.aspeed = PI / 90; this.playerPos = this.pos; this.playerDis = 0; } move(fw) { this.prevPos.set(this.pos); const vel = p5.Vector.fromAngle(this.a); if (fw) { vel.mult(this.speed); this.pos.add(-vel.x, 0, vel.y); } else { vel.mult(this.speed); this.pos.add(vel.x, 0, -vel.y); } if (this.pos.x \u0026gt; 400) { this.pos.x = 400 } if (this.pos.z \u0026gt; 400) { this.pos.z = 400 } if (this.pos.x \u0026lt; -400) { this.pos.x = -400 } if (this.pos.z \u0026lt; -410) { this.pos.z = -410 } } movement() { if (keyIsDown(65)) this.turn(1); if (keyIsDown(68)) this.turn(-1); if (keyIsDown(87)) this.move(true); if (keyIsDown(83)) this.move(false); } turn(dir) { this.a += dir * this.aspeed; } render(fbo, fboOff1, fboOff2) { fbo.push(); if (fboOff1) { fbo.translate(0, 0, -870); } if (fboOff2) { fbo.translate(0, 0, 870); } fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.noStroke(); fbo.push(); fbo.rotateZ(PI); fbo.rotateY(HALF_PI); fbo.texture(fox_tex); fbo.model(fox); fbo.pop(); fbo.pop(); } } class Portal { constructor(x, y, z, a) { this.pos = createVector(x, y, z); this.len = 220; this.a = a; this.portalPos = 0; this.linkedPortal = null; } link(other) { this.linkedPortal = other; other.linkedPortal = this; } check_(player) { const relativePos = player.playerPos.copy(); relativePos.sub(this.portalPos); relativePos.rotate(-this.a); const relativePrevPos = player.prevPos.copy(); relativePrevPos.sub(this.portalPos); relativePrevPos.rotate(-this.a); if ((abs(relativePos.z) \u0026lt; 38) !== (abs(relativePrevPos.z) \u0026lt; 38) \u0026amp;\u0026amp; abs(relativePos.x) \u0026lt; this.len / 2) { console.log(\u0026#34;Teletransportado\u0026#34;); // player.a += this.linkedPortal.a - this.a; return true; } return false; } check(player) { return this.check_(player); } render(fbo, numberPortal, texElement, portalShader) { fbo.push() fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.push() fbo.translate(0, 0, -1); if (numberPortal === 0) { fbo.fill(0, 0, 255) } else { fbo.fill(255, 158, 0) } fbo.circle(0, 0, 260) fbo.pop() if (portalShader) { fbo.shader(portalShader); fbo.emitResolution(portalShader); portalShader.setUniform(\u0026#39;texture\u0026#39;, texElement); } else { if (texElement) { fbo.texture(texElement); } } fbo.circle(0, 0, 250) this.portalPos = fbo.treeLocation(/*[0, 0, 0],*/ { from: Tree.MODEL, to: Tree.WORLD }); fbo.pop() } } function scene(fbo, fboOff1, fboOff2, frontWall, backWall) { fbo.background(120); fbo.reset(); fbo.rectMode(CENTER); fbo.noStroke(); fbo.push(); if (fboOff1) { fbo.translate(0, 0, -870); } if (fboOff2) { fbo.translate(0, 0, 870); } fbo.ambientLight(255); fbo.push(); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(kemonaSilver) fbo.box(100) fbo.pop(); fbo.push(); fbo.translate(-350, 0, -350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat1_tex) fbo.model(cat1); fbo.pop(); fbo.push(); fbo.translate(350, 0, 350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat2_tex) fbo.model(cat2); fbo.pop(); // PISO fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, 110); fbo.rotateX(HALF_PI); fbo.box(900, 900, 20); fbo.pop(); // PAREDES if (frontWall) { // Frontal Z+ fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, -25, 450); fbo.box(900, 250, 20); fbo.pop(); } if (backWall) { // Trasera Z- fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, -25, -450); fbo.box(900, 250, 20); fbo.pop(); } // Lateral Derecha X+ fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(450, -25, 0); fbo.rotateY(HALF_PI); fbo.box(900, 250, 20); fbo.pop(); // Trasera Izquierda X- fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(-450, -25, 0); fbo.rotateY(HALF_PI); fbo.box(900, 250, 20); fbo.pop(); fbo.pop(); } function keyPressed() { if (keyCode === 67) { if (changeCam === 0) { changeCam = 1; } } if (keyCode === 73) { if (press === 0) { press = 1; } } } function camFovCoordinates(radio, posVec, angle, hy, chy) { let vecAngle = p5.Vector.fromAngle(angle); let radioCam = -10; return { xp: (posVec.x + (radioCam * vecAngle.x)), yp: posVec.y + hy, zp: (posVec.z + (radioCam * vecAngle.y)), xc: (posVec.x + (radio * vecAngle.x)), yc: posVec.y + chy, zc: (posVec.z + (radio * vecAngle.y)), xn: 0, yn: 1, zn: 0 }; } Comandos Tecla Descripción W Mover hacia adelante A Girar hacia la izquierda D Girar hacia la derecha S Mover hacia atrás C Cambiar vista primera/tercera persona Portal Shaders Con Múltiples reflejos # En esta última etapa se incorporan los dos objetivos faltantes en la etapa anterior.\nPrimero, se corrigen las colisiones y la cantidad de veces que puede entrar el personaje al portal.\nY por último, se adiciona dentro del portal los reflejos creados en el portal opuesto, de modo que dentro del portal se visualizan hasta 5 proyecciones de sí mismo para dar un efecto más realista y que acate los conceptos postulados por el juego original.\nportalShaderV3.js let press = 0; // variable get info funcions let changeCam = 0; //variable that indicate the position of the camera let angle = 0; // angle of rotation of some objects let kemonaSilver; // Textura del cubo central let player1, playerOnPortal1, playerOnPortal2; let fbo1, fbo1TextPort1, fbo1TextPort2; let fbo1Off1, fbo1Off2, fbo1Off3, fbo1Off4, fbo2Off1, fbo2Off2, fbo2Off3, fbo2Off4; let portalShader, shader1Aux1, shader1Aux2, shader1Aux3, shader1Aux4, shader2Aux1, shader2Aux2, shader2Aux3, shader2Aux4; let portal1Onfbo1, portal2Onfbo1; let portal1Onfbo1Off, portal2Onfbo1Off; let portal1Off1, portal1Off2, portal1Off3, portal2Off1, portal2Off2, portal2Off3; // obj models let fox; let cat1; let cat2; // texture of models let fox_tex; let cat1_tex; let cat2_tex; let set1 = 0, set2 = 0; let starCheck1 = 0, starCheck2 = 0, restart = 0; let teleportedFbo1 = false, teleportedFbo2 = true; let cam1, cam2; let onCam1 = true, onCam2 = false; let dummy; function preload() { kemonaSilver = loadImage(\u0026#39;/assets/image/KemonaPlushSilver.jpg\u0026#39;); fox_tex = loadImage(\u0026#39;/assets/models/fox.png\u0026#39;); fox = loadModel(\u0026#39;/assets/models/fox.obj\u0026#39;, true); cat1_tex = loadImage(\u0026#39;/assets/models/cat_plush_01.png\u0026#39;); cat1 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); cat2_tex = loadImage(\u0026#39;/assets/models/cat_plush_02.png\u0026#39;); cat2 = loadModel(\u0026#39;/assets/models/catPlush.obj\u0026#39;, true); portalShader = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader1Aux1 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader1Aux2 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader1Aux3 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader1Aux4 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader2Aux1 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader2Aux2 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader2Aux3 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); shader2Aux4 = readShader(\u0026#39;/assets/shader/portal2.frag\u0026#39;, { varyings: Tree.NONE }); } function setup() { createCanvas(900, 900, WEBGL); dummy = createGraphics(1, 1, WEBGL); fbo1 = createGraphics(900, 900, WEBGL); fbo1Off1 = createGraphics(900, 900, WEBGL); fbo1Off2 = createGraphics(900, 900, WEBGL); fbo1Off3 = createGraphics(900, 900, WEBGL); fbo1Off4 = createGraphics(900, 900, WEBGL); fbo2Off1 = createGraphics(900, 900, WEBGL); fbo2Off2 = createGraphics(900, 900, WEBGL); fbo2Off3 = createGraphics(900, 900, WEBGL); fbo2Off4 = createGraphics(900, 900, WEBGL); fbo1TextPort1 = createGraphics(900, 900, WEBGL); fbo1TextPort2 = createGraphics(900, 900, WEBGL); player1 = new Player(0, 0, 100); playerOnPortal1 = new Player(0, 0, 0); playerOnPortal2 = new Player(0, 0, 0); portal1Onfbo1 = new Portal(0, 0, -437, 0); portal2Onfbo1 = new Portal(0, 0, 437, PI); portal2Onfbo1.link(portal1Onfbo1); portal1Onfbo1Off = new Portal(0, 0, -(437 + (1 * 880)), 0); portal1Off1 = new Portal(0, 0, -(437 + (2 * 880)), 0); portal1Off2 = new Portal(0, 0, -(437 + (3 * 880)), 0); portal1Off3 = new Portal(0, 0, -(437 + (4 * 880)), 0); portal2Onfbo1Off = new Portal(0, 0, (437 + (1 * 880)), PI); portal2Off1 = new Portal(0, 0, (437 + (2 * 880)), PI); portal2Off2 = new Portal(0, 0, (437 + (3 * 880)), PI); portal2Off3 = new Portal(0, 0, (437 + (4 * 880)), PI); cam1 = fbo1.createCamera(); // firts person camera cam2 = new Dw.EasyCam(fbo1._renderer, { distance: 848.5208406737183, // scalar (optional) center: [0, 0, 0], // vector (optional) rotation: [0.9686568165691878, -0.24785495689905887, -0.014390494259618537, -0.008050200592452867], // quaternion (optional) }); cam2.attachMouseListeners(this._renderer); let state2 = cam2.getState(); cam2.state_reset = state2; // state to use on reset (double-click/tap) cam2.setViewport([0, 0, 900, 900]); console.log(\u0026#34;XD\u0026#34;); } function draw() { // 1. compute current main canvas camera params let position = fbo1.treeLocation(); let center = p5.Vector.add(position, fbo1.treeDisplacement()); let up = fbo1.treeDisplacement(Tree.j); fbo1TextPort1.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo1TextPort2.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo1Off1.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo1Off2.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo1Off3.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo1Off4.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo2Off1.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo2Off2.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo2Off3.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); fbo2Off4.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); // 2. set scenes scene(fbo1, 0, 1, 1); // Escena Principal scene(fbo1TextPort1, -(1 * 880), 0, 1); // Escena Portal 1 de la escena principal scene(fbo1Off1, -(2 * 880), 0, 1); // Escena Portal 1 de la escena Off 1 scene(fbo1Off2, -(3 * 880), 0, 1); // Escena Portal 1 de la escena Off 2 scene(fbo1Off3, -(4 * 880), 0, 1); // Escena Portal 1 de la escena Off 3 scene(fbo1Off4, -(5 * 880), 0, 1); // Escena Portal 1 de la escena Off 4 scene(fbo1TextPort2, (1 * 880), 1, 0); // Escena Portal 2 de la escena principal scene(fbo2Off1, (2 * 880), 1, 0); // Escena Portal 2 de la escena Off 1 scene(fbo2Off2, (3 * 880), 1, 0); // Escena Portal 2 de la escena Off 2 scene(fbo2Off3, (4 * 880), 1, 0); // Escena Portal 2 de la escena Off 3 scene(fbo2Off4, (5 * 880), 1, 0); // Escena Portal 2 de la escena Off 4 player1.movement(); player1.render(fbo1, 0); if (teleportedFbo1 \u0026amp;\u0026amp; !teleportedFbo2) { if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { starCheck1 = 1; } if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { starCheck2 = 1; } if (starCheck1) { teleportedFbo1 = portal1Onfbo1.check(player1) } if (starCheck2) { teleportedFbo2 = portal2Onfbo1.check(player1) } } if (!teleportedFbo1 \u0026amp;\u0026amp; teleportedFbo2) { if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { starCheck1 = 1; } if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { starCheck2 = 1; } if (starCheck1) { teleportedFbo1 = portal1Onfbo1.check(player1) } if (starCheck2) { teleportedFbo2 = portal2Onfbo1.check(player1) } } if ((!teleportedFbo1 \u0026amp;\u0026amp; !teleportedFbo2)) { if (abs(player1.playerPos.z) \u0026lt; (abs(portal1Onfbo1.portalPos.z) - 40)) { starCheck1 = 1; } if (abs(player1.playerPos.z) \u0026lt; (abs(portal2Onfbo1.portalPos.z) - 40)) { starCheck2 = 1; } if (starCheck1) { teleportedFbo1 = portal1Onfbo1.check(player1) } if (starCheck2) { teleportedFbo2 = portal2Onfbo1.check(player1) } if (teleportedFbo1) { set1 = 1; } if (teleportedFbo2) { set2 = 1; } if (set1) { player1.pos = portal2Onfbo1.portalPos; starCheck2 = 0; set1 = 0; } if (set2) { player1.pos = portal1Onfbo1.portalPos; starCheck1 = 0; set2 = 0; } } if (player1.playerPos != 0) { playerOnPortal1.pos = player1.pos playerOnPortal1.a = player1.a playerOnPortal1.render(fbo1TextPort1, -(1 * 880)); playerOnPortal1.render(fbo1Off1, -(2 * 880)); playerOnPortal1.render(fbo1Off2, -(3 * 880)); playerOnPortal1.render(fbo1Off3, -(4 * 880)); playerOnPortal1.render(fbo1Off4, -(5 * 880)); playerOnPortal2.pos = player1.pos playerOnPortal2.a = player1.a playerOnPortal2.render(fbo1TextPort2, (1 * 880)); playerOnPortal2.render(fbo2Off1, (2 * 880)); playerOnPortal2.render(fbo2Off2, (3 * 880)); playerOnPortal2.render(fbo2Off3, (4 * 880)); playerOnPortal2.render(fbo2Off4, (5 * 880)); } angle += 0.007 portal1Off3.render(fbo1Off3, 0, fbo1Off4, shader1Aux4); portal1Off2.render(fbo1Off2, 0, fbo1Off3, shader1Aux3); portal1Off1.render(fbo1Off1, 0, fbo1Off2, shader1Aux2); portal1Onfbo1Off.render(fbo1TextPort1, 0, fbo1Off1, shader1Aux1); portal1Onfbo1.render(fbo1, 0, fbo1TextPort1, portalShader); portal2Off3.render(fbo2Off3, 1, fbo2Off4, shader2Aux4); portal2Off2.render(fbo2Off2, 1, fbo2Off3, shader2Aux3); portal2Off1.render(fbo2Off1, 1, fbo2Off2, shader2Aux2); portal2Onfbo1Off.render(fbo1TextPort2, 1, fbo2Off1, shader2Aux1); portal2Onfbo1.render(fbo1, 1, fbo1TextPort2, portalShader); let camCoor = camFovCoordinates(-900, player1.pos, -player1.a, -60, 40); cam1.camera(camCoor.xp, camCoor.yp, camCoor.zp, camCoor.xc, camCoor.yc, camCoor.zc, camCoor.xn, camCoor.yn, camCoor.zn) if (changeCam) { if (onCam1) { cam2.setCanvas(dummy._renderer); fbo1.setCamera(cam1) onCam1 = false; onCam2 = true; } else { if (onCam2) { fbo1.reset(); cam2.setCanvas(fbo1._renderer); onCam1 = true; onCam2 = false; } } changeCam = 0; } if (press) { console.log({ x: player1.pos.x, y: player1.pos.y, z: player1.pos.z }); console.log({ angle: player1.a }); let v = p5.Vector.fromAngle(player1.a); console.log({ x: v.x, y: v.y, z: v.z }); press = 0; } beginHUD(); image(fbo1, 0, 0); endHUD(); } class Player { constructor(x, y, z) { this.pos = createVector(x, y, z); this.prevPos = this.pos.copy(); this.a = 0; this.speed = 3; this.aspeed = PI / 90; this.playerPos = 0; this.playerDis = 0; } move(fw) { this.prevPos.set(this.pos); const vel = p5.Vector.fromAngle(this.a); if (fw) { vel.mult(this.speed); this.pos.add(-vel.x, 0, vel.y); } else { vel.mult(this.speed); this.pos.add(vel.x, 0, -vel.y); } if (this.pos.x \u0026gt; 400) { this.pos.x = 400 } if (this.pos.z \u0026gt; 400) { this.pos.z = 400 } if (this.pos.x \u0026lt; -400) { this.pos.x = -400 } if (this.pos.z \u0026lt; -410) { this.pos.z = -410 } } movement() { if (keyIsDown(65)) this.turn(1); if (keyIsDown(68)) this.turn(-1); if (keyIsDown(87)) this.move(true); if (keyIsDown(83)) this.move(false); } turn(dir) { this.a += dir * this.aspeed; } render(fbo, displacement) { fbo.push(); fbo.translate(0, 0, displacement); fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.noStroke(); fbo.push(); fbo.rotateZ(PI); fbo.rotateY(HALF_PI); fbo.texture(fox_tex); fbo.model(fox); this.playerPos = fbo.treeLocation(/*[0, 0, 0],*/ { from: Tree.MODEL, to: Tree.WORLD }); this.playerDis = fbo.treeDisplacement(/*[0, 0, 0],*/ { from: Tree.MODEL, to: Tree.WORLD }); fbo.pop(); fbo.pop(); } } class Portal { constructor(x, y, z, a) { this.pos = createVector(x, y, z); this.len = 220; this.a = a; this.portalPos = 0; this.linkedPortal = null; } link(other) { this.linkedPortal = other; other.linkedPortal = this; } check_(player) { const relativePos = player.playerPos.copy(); relativePos.sub(this.portalPos); relativePos.rotate(-this.a); const relativePrevPos = player.prevPos.copy(); relativePrevPos.sub(this.portalPos); relativePrevPos.rotate(-this.a); if ((abs(relativePos.z) \u0026lt; 38) !== (abs(relativePrevPos.z) \u0026lt; 38) \u0026amp;\u0026amp; abs(relativePos.x) \u0026lt; this.len / 2) { console.log(\u0026#34;Teletransportado\u0026#34;); return true; } return false; } check(player) { return this.check_(player); } render(fbo, numberPortal, texElement, portalShader) { fbo.push() fbo.translate(this.pos.x, this.pos.y, this.pos.z); fbo.rotateY(this.a); fbo.push() fbo.translate(0, 0, -1); if (numberPortal === 0) { fbo.fill(0, 0, 255) } else { fbo.fill(255, 158, 0) } fbo.circle(0, 0, 260) fbo.pop() if (portalShader) { fbo.resetShader(); fbo.shader(portalShader); fbo.emitResolution(portalShader); portalShader.setUniform(\u0026#39;texture\u0026#39;, texElement); } else { if (texElement) { fbo.texture(texElement); } } fbo.circle(0, 0, 250) this.portalPos = fbo.treeLocation(/*[0, 0, 0],*/ { from: Tree.MODEL, to: Tree.WORLD }); fbo.pop() } } function scene(fbo, displacement, frontWall, backWall) { fbo.background(120); fbo.reset(); fbo.rectMode(CENTER); fbo.noStroke(); fbo.push(); fbo.translate(0, 0, displacement); fbo.ambientLight(255); fbo.push(); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(kemonaSilver) fbo.box(100) fbo.pop(); fbo.push(); fbo.translate(-350, 0, -350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat1_tex) fbo.model(cat1); fbo.pop(); fbo.push(); fbo.translate(350, 0, 350); fbo.rotateZ(angle) fbo.rotateX(angle) fbo.rotateY(angle) fbo.texture(cat2_tex) fbo.model(cat2); fbo.pop(); // PISO fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, 110); fbo.rotateX(HALF_PI); fbo.box(900, 900, 20); fbo.pop(); // PAREDES if (frontWall) { // Frontal Z+ fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, -25, 450); fbo.box(900, 250, 20); fbo.pop(); } if (backWall) { // Trasera Z- fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(0, -25, -450); fbo.box(900, 250, 20); fbo.pop(); } // Lateral Derecha X+ fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(450, -25, 0); fbo.rotateY(HALF_PI); fbo.box(900, 250, 20); fbo.pop(); // Trasera Izquierda X- fbo.push(); fbo.stroke(2); fbo.ambientLight(255); fbo.ambientMaterial(100); fbo.translate(-450, -25, 0); fbo.rotateY(HALF_PI); fbo.box(900, 250, 20); fbo.pop(); fbo.pop(); } function keyPressed() { if (keyCode === 67) { if (changeCam === 0) { changeCam = 1; } } if (keyCode === 73) { if (press === 0) { press = 1; } } } function camFovCoordinates(radio, posVec, angle, hy, chy) { let vecAngle = p5.Vector.fromAngle(angle); let radioCam = -10; return { xp: (posVec.x + (radioCam * vecAngle.x)), yp: posVec.y + hy, zp: (posVec.z + (radioCam * vecAngle.y)), xc: (posVec.x + (radio * vecAngle.x)), yc: posVec.y + chy, zc: (posVec.z + (radio * vecAngle.y)), xn: 0, yn: 1, zn: 0 }; } Comandos Tecla Descripción W Mover hacia adelante A Girar hacia la izquierda D Girar hacia la derecha S Mover hacia atrás C Cambiar vista primera/tercera persona Referencias\nhttps://visualcomputing.github.io/docs/shaders/non-euclidean_geometry/ https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana\n"},{"id":6,"href":"/docs/talleres/shadersExercises/spatialCoherence/","title":"Spatial Coherence","section":"Shaders Exercises","content":" Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura.\nSketch Pixelator (Shader) # pixelator.js \u0026#39;use strict\u0026#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(\u0026#39;/assets/shader/pixelator.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/cheems.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); } function setup() { createCanvas(600, 600, WEBGL); textureMode(NORMAL); noStroke(); resolution = createSlider(1, 200, 30, 1); resolution.position(10, 35); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); image_select = createSelect(); image_select.position(10, 10); image_select.option(\u0026#39;slav cheems\u0026#39;); image_select.option(\u0026#39;dark cheems\u0026#39;); image_select.option(\u0026#39;cheems\u0026#39;); image_select.selected(\u0026#39;slav cheems\u0026#39;); image_select.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); mode = createSelect(); mode.position(120, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;pixelator\u0026#39;); mode.selected(\u0026#39;original\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); // which previous exercise does this code actually solve? /* y v | | (-1,1)| (1,1) (0,1) (1,1) *_____|_____* *__________* | | | | | |_____|_____|__x | texture | | | | | space | *_____|_____* *__________*___ u (-1,-1) (1,-1) (0,0) (1,0) */ // texture coordinates are in the range 0..1 // so we need to map the coordinates to the range -1..1 // to get the correct texture mapping loadPixelImage(); } function loadPixelImage() { if (image_select.value() == \u0026#39;slav cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img1); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img1); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } else if (image_select.value() == \u0026#39;dark cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img2); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img2); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } else if (image_select.value() == \u0026#39;cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img3); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img3); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } beginShape(); vertex(-1, -1, 0, 0, 1); vertex(1, -1, 0, 1, 1); vertex(1, 1, 0, 1, 0); vertex(-1, 1, 0, 0, 0); endShape(); } pixelator.frag precision mediump float; // source (image or video) is sent by the sketch uniform sampler2D source; // displays original uniform bool original; // target horizontal \u0026amp; vertical resolution uniform float resolution; // interpolated texcoord (same name and type as in vertex shader) // defined as a (normalized) vec2 in [0..1] varying vec2 texcoords2; void main() { if (original) { gl_FragColor = texture2D(source, texcoords2); } else { // define stepCoord to sample the texture source as a 3-step process: // i. define stepCoord as a texcoords2 remapping in [0.0, resolution] ∈ R vec2 stepCoord = texcoords2 * resolution; // ii. remap stepCoord in [0.0, resolution] ∈ Z // see: https://thebookofshaders.com/glossary/?search=floor stepCoord = floor(stepCoord); // iii. remap stepCoord in [0.0, 1.0] ∈ R stepCoord = stepCoord / vec2(resolution); // source texel gl_FragColor = texture2D(source, stepCoord); // ✨ source texels may be used to compute image palette lookup keys, // such as in video \u0026amp; photographic mosaics or ascii art visualizations. } } Sketch Pixelator (Software) # pixelatorSW.js let img1, img2, img3; // creates image variable let resolution, image_select, mode; let size; // element size let loadOnce = false; function preload() { img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/cheems.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); } function setup() { createCanvas(600, 600); resolution = createSlider(1, 200, 30, 1); resolution.position(10, 35); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); image_select = createSelect(); image_select.position(10, 10); image_select.option(\u0026#39;slav cheems\u0026#39;); image_select.option(\u0026#39;dark cheems\u0026#39;); image_select.option(\u0026#39;cheems\u0026#39;); image_select.selected(\u0026#39;slav cheems\u0026#39;); image_select.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); mode = createSelect(); mode.position(120, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;pixelator\u0026#39;); mode.selected(\u0026#39;original\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); size = floor(height / resolution.value()); loadPixelImage(); } function loadPixelImage() { if (image_select.value() == \u0026#39;slav cheems\u0026#39;) { image(img1, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } else if (image_select.value() == \u0026#39;dark cheems\u0026#39;) { image(img2, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } else if (image_select.value() == \u0026#39;cheems\u0026#39;) { image(img3, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } } function pixelator() { loadPixels(); for (var y = 0; y \u0026lt; height; y++) { for (var x = 0; x \u0026lt; width; x++) { var index = (x + y * width) * 4; var r = pixels[index + 0]; var g = pixels[index + 1]; var b = pixels[index + 2]; var a = pixels[index + 3]; noStroke(); fill(r, g, b, a); rect(x, y, size, size); x = x + size - 1 } y = y + size - 1 } } Referencias\nhttps://visualcomputing.github.io/docs/shaders/spatial_coherence/\n"},{"id":7,"href":"/docs/talleres/shadersExercises/texturing/","title":"Texturing","section":"Shaders Exercises","content":" Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \\(0 \\leq X \\leq 1\\) y \\(0 \\leq Y \\leq 1\\) Sketch de UV Texturing # uv.js let uvShader; function preload() { // Define geometry directly in clip space (i.e., matrices: Tree.NONE). // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(\u0026#39;/sketches/shaders/uv.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { // shaders require WEBGL mode to work createCanvas(300, 300, WEBGL); noStroke(); // see: https://p5js.org/reference/#/p5/shader shader(uvShader); // https://p5js.org/reference/#/p5/textureMode // best and simplest is to just always used NORMAL textureMode(NORMAL); } function draw() { background(0); /* clip-space quad shape, i.e., both x and y vertex coordinates ∈ [-1..1] since textureMode is NORMAL, texture coordinates ∈ [-1..1] see: https://p5js.org/reference/#/p5/beginShape https://p5js.org/reference/#/p5/vertex y v | | (-1,1)| (1,1) (0,1) (1,1) *_____|_____* *__________* | | | | | |_____|_____|__x | texture | | | | | space | *_____|_____* *__________*___ u (-1,-1) (1,-1) (0,0) (1,0) */ beginShape(); vertex(-1, -1, 0, 0, 0); vertex( 1, -1, 0, 1, 0); vertex( 1, 1, 0, 1, 1); vertex(-1, 1, 0, 0, 1); endShape(); // ✨ it\u0026#39;s worth noting (not mentioned in the p5 api docs though) // that quad (https://p5js.org/reference/#/p5/quad) also adds the // texture coords to each of its vertices. Hence: // quad(-1, -1, 1, -1, 1, 1, -1, 1); // produce the same results as the above beginShape / endShape } uv.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 0.0, 1.0); } Sketch de UV Texturing (Coordenadas Inversas) # uv.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.x, 1.0 - texcoords2.y, 0.0, 1.0); } Sketch de UV Texturing (Agregando Color Azul) # uvBlueX.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.x, 1.0); } uvBlueY.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.y, 1.0); } Sketch de UV Screen # uv_screen.js let easycam; let uvShader; let opacity; let mode; function preload() { // Define geometry in world space (i.e., matrices: Tree.pmvMatrix). // The projection and modelview matrices may be emitted separately // (i.e., matrices: Tree.pMatrix | Tree.mvMatrix), which actually // leads to the same gl_Position result. // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(\u0026#39;/assets/shader/uv_alpha.frag\u0026#39;, { matrices: Tree.pmvMatrix, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 600, WEBGL); // easycam stuff let state = { distance: 250, // scalar center: [0, 0, 0], // vector rotation: [0, 0, 0, 1], // quaternion }; easycam = createEasyCam(); easycam.state_reset = state; // state to use on reset (double-click/tap) easycam.setState(state, 2000); // now animate to that state textureMode(NORMAL); opacity = createSlider(0, 1, 0.5, 0.01); opacity.position(10, 25); opacity.style(\u0026#39;width\u0026#39;, \u0026#39;280px\u0026#39;); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;quad\u0026#39;); mode.option(\u0026#39;ellipse\u0026#39;); mode.option(\u0026#39;triangleUP\u0026#39;); mode.option(\u0026#39;triangleDOWN\u0026#39;); mode.selected(\u0026#39;uvShaderBlueX\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(200); // reset shader so that the default shader is used to render the 3D scene resetShader(); // world space scene axes(); grid(); translate(0, -70); rotateY(0.5); fill(color(255, 0, 255, 125)); box(30, 50); translate(70, 70); fill(color(0, 255, 255, 125)); sphere(30, 50); // use custom shader shader(uvShader); uvShader.setUniform(\u0026#39;opacity\u0026#39;, opacity.value()); // screen-space quad (i.e., x ∈ [0..width] and y ∈ [0..height]) // see: https://github.com/VisualComputing/p5.treegl#heads-up-display loadFigure(mode.value()); } function mouseWheel(event) { //comment to enable page scrolling return false; } function loadFigure(value) { if (value == \u0026#39;quad\u0026#39;) { beginHUD(); noStroke(); quad(0, 0, width, 0, width, height, 0, height); endHUD(); } else if (value == \u0026#39;ellipse\u0026#39;) { beginHUD(); noStroke(); ellipse(width / 2, height / 2, width, height); endHUD() } else if (value == \u0026#39;triangleUP\u0026#39;) { beginHUD(); noStroke(); triangle(0, 0, width, 0, width, height); endHUD(); } else if (value == \u0026#39;triangleDOWN\u0026#39;) { beginHUD(); noStroke(); triangle(0, 0, 0, height, width, height); endHUD(); } } uv_alpha.frag precision mediump float; varying vec2 texcoords2; varying vec4 color4; // uniform is sent by the sketch uniform float opacity; void main() { gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.x, opacity); } Sketch de Luma y Aritmetic Mean # luma_mena.js let lumaShader, meanShader; let img1, img2; let grey_scale, mode; function preload() { lumaShader = readShader(\u0026#39;/assets/shader/luma.frag\u0026#39;, { varyings: Tree.texcoords2 }); meanShader = readShader(\u0026#39;/assets/shader/mean.frag\u0026#39;, { varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/fire.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/fire2.jpg\u0026#39;); } function setup() { createCanvas(600, 600, WEBGL); noStroke(); textureMode(NORMAL); shader(lumaShader); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;fire 1\u0026#39;); mode.option(\u0026#39;fire 2\u0026#39;); mode.selected(\u0026#39;fire 1\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); grey_scale = createSelect(); grey_scale.position(60, 10); grey_scale.option(\u0026#39;original\u0026#39;); grey_scale.option(\u0026#39;luma\u0026#39;); grey_scale.option(\u0026#39;average\u0026#39;); grey_scale.selected(\u0026#39;original\u0026#39;); grey_scale.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadShaderImage(); } function loadShaderImage() { if (mode.value() == \u0026#39;fire 1\u0026#39;) { if (grey_scale.value() == \u0026#39;luma\u0026#39;) { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img1); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else if (grey_scale.value() == \u0026#39;average\u0026#39;) { resetShader(); shader(meanShader); meanShader.setUniform(\u0026#39;texture\u0026#39;, img1); meanShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img1); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;fire 2\u0026#39;) { if (grey_scale.value() == \u0026#39;luma\u0026#39;) { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img2); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else if (grey_scale.value() == \u0026#39;average\u0026#39;) { resetShader(); shader(meanShader); meanShader.setUniform(\u0026#39;texture\u0026#39;, img2); meanShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img2); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } luma.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; // returns luma of given texel float luma(vec3 texel) { return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(luma(texel.rgb))), 1.0) : texel; } mean.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; // returns luma of given texel float luma(vec3 texel) { return (texel.r + texel.g + texel.b)/3.0; } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(luma(texel.rgb))), 1.0) : texel; } Sketch de HSV # hsv.js let hsvShader; let img1, img2, img3, img4, img5; let grey_scale, mode; function preload() { hsvShader = readShader(\u0026#39;/assets/shader/hsv.frag\u0026#39;, { varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/landscape1.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/landscape2.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/landscape3.jpg\u0026#39;); img4 = loadImage(\u0026#39;/assets/image/landscape4.jpg\u0026#39;); img5 = loadImage(\u0026#39;/assets/image/landscape5.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); img4.resize(0, height); img5.resize(0, height); } function setup() { createCanvas(600, 600, WEBGL); noStroke(); textureMode(NORMAL); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;landscape 1\u0026#39;); mode.option(\u0026#39;landscape 2\u0026#39;); mode.option(\u0026#39;landscape 3\u0026#39;); mode.option(\u0026#39;landscape 4\u0026#39;); mode.option(\u0026#39;landscape 5\u0026#39;); mode.selected(\u0026#39;landscape 1\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); grey_scale = createSelect(); grey_scale.position(110, 10); grey_scale.option(\u0026#39;original\u0026#39;); grey_scale.option(\u0026#39;hsv\u0026#39;); grey_scale.selected(\u0026#39;original\u0026#39;); grey_scale.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadShaderImage(); } function loadShaderImage() { if (mode.value() == \u0026#39;landscape 1\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img1); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img1); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 2\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img2); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img2); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 3\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img3); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img3); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 4\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img4); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img4); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 5\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img5); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img5); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } hsv.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; float modI(float a,float b) { float m=a-floor((a+0.5)/b)*b; return floor(m+0.5); } vec3 hsv(vec3 c) { float rValor = c.r; float gValor = c.g; float bValor = c.b; float maximo = max(max(rValor, gValor), bValor); float minimo = min(max(rValor, gValor), bValor); float h = 0.0; if(maximo == rValor){ h = 60.0 * modI((gValor - bValor)/(maximo - minimo), 6.0); }else if (maximo == gValor){ h = 60.0 * (((bValor - rValor) / (maximo - minimo)) + 2.0); }else{ h = 60.0 * (((rValor - gValor) / (maximo - minimo)) + 4.0); } float s = 0.0; if(maximo != 0.0){ s = (maximo - minimo) / maximo; }else{ s = 0.0; } float v = maximo; return vec3(h, s, v); } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(hsv(texel.rgb))), 1.0) : texel; } Referencias\nhttps://visualcomputing.github.io/docs/shaders/texturing/ https://vcwork.github.io/project/docs/Entrega3/parte1/ https://en.wikipedia.org/wiki/HSL_and_HSV\n"},{"id":8,"href":"/posts/blog/","title":"Blog","section":"Blog","content":" Intregantes # Brayan David Leon Sanabria # Juan Sebastian Silva Castillo # "}]