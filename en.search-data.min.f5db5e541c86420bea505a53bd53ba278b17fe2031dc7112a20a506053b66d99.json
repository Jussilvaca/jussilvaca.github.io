[{"id":0,"href":"/docs/talleres/ilusiones/","title":"Ilusiones","section":"Talleres","content":" Kernels de imagenes # Kernels de imagenes # Shortcuts Tecla Description F Cambiar mascara G Mostrar histograma H Cambiar imagen V Disminuir brillo B Aumentar brillo R Resetear imagen Ilusiones # Ver color en una imagen a blanco y negro # Nosotros tenemos tres tipos de conos en nuestros ojos, sensibles a las ondas de luz asociadas a los colores verde, rojo y azul. Cuando nos exponemos a una gran cantidad de luz de un determinado color, estos conos se fatigan y dejan de responder temporalmente. Cuando volvemos a ver la imagen en blanco y negro, solo actúan los conos que no están fatigados, por lo que vemos los colores complementarios a los \u0026ldquo;fatigados\u0026rdquo; durante unos segundos.\nShortcuts Tecla Description R Reiniciar el Timer O Mostrar Imagen Original Sube cualquier imagen Referencias\nhttps://verne.elpais.com/verne/2015/11/20/articulo/1448008967_394846.html\nFenómeno Phi (φ) # El término fenómeno phi se usa en un sentido estricto para un movimiento aparente que se observa si dos estímulos ópticos cercanos se presentan en alternancia con una frecuencia relativamente alta.\nSe aplica también a todos los movimientos aparentes que se pueden ver si se presentan alternativamente dos estímulos ópticos cercano.\nNacimiento de la psicología de Gestalt / Gestalismo / Configuracionismo # Los psicólogos de la Gestalt enfatizaron que los organismos perciben patrones o configuraciones completos, no solo componentes individuales. “El todo es más que la suma de sus partes”.\nReverse Phi Ilumination (φ) # Como el sistema visual humano percibe el movimiento phi aparente con dos estímulos ópticos estacionarios y similares presentados uno al lado del otro expuestos sucesivamente con alta frecuencia, también hay una versión inversa de este movimiento, que es la ilusión phi inversa. La ilusión phi inversa es el tipo de fenómeno phi que se desvanece o se disuelve de su dirección positiva a la negativa desplazada, de modo que el movimiento aparente que perciben los humanos es opuesto al desplazamiento físico real. La ilusión de phi inversa suele ir seguida de patrones en blanco y negro.\nSe cree que la ilusión de phi inversa es de hecho efectos de brillo, que ocurre cuando la imagen que invierte el brillo se mueve a través de nuestra retina. Puede explicarse por los mecanismos del modelo de campo receptivo visual, donde los estímulos visuales se suman espacialmente (un proceso que es inverso a la diferenciación espacial). Esta suma espacial desdibuja un poco el contorno y, por lo tanto, cambia el brillo percibido.\nShortcuts Tecla Description Espacio Mostrar regilla Slider V Ilusión - Desplazamiento vertical Slider H Ilusión - Desplazamiento horizontal Otro ejemplo # Referencias: https://michaelbach.de/ot/mot-reversePhi/index.html https://www.facebook.com/watch/?v=10158770212388374 https://www.muyinteresante.com.mx/cuerpo-mente/ilusiones-opticas-que-demuestra-lo-facil-que-es-enganar-al-cerebro-humano/ https://news.stanford.edu/pr/2011/pr-reverse-phi-motion-091211.html https://jov.arvojournals.org/article.aspx?articleid=2121864#133476828 Leaning Tower Illution # La ilusión de la torre inclinada es una ilusión visual que se ve en un par de imágenes idénticas de la Torre Inclinada de Pisa fotografiadas desde abajo. Aunque las imágenes son duplicadas, se tiene la impresión de que la torre de la derecha se inclina más, como si fuera fotografiada desde otro ángulo. La ilusión fue descubierta por Frederick Kingdom, Ali Yoonessi y Elena Gheorghiu en la Universidad McGill , y ganó el primer premio en el Concurso de Mejor Ilusión del Año 2007.\nLos autores sugieren que la ilusión se produce por la forma en que el sistema visual tiene en cuenta la perspectiva. Cuando dos torres idénticas se elevan en paralelo pero se ven desde abajo, sus contornos correspondientes convergen en la imagen retiniana debido a la perspectiva. El sistema visual normalmente \u0026ldquo;corrige\u0026rdquo; la distorsión de la perspectiva y, como resultado, percibe las torres correctamente, es decir, que se elevan en paralelo. Sin embargo, en el caso de las dos imágenes idénticas de la torre de Pisa, los contornos correspondientes de las torres no convergen sino que discurren en paralelo y, como resultado, las torres se perciben como no paralelas, es decir, divergentes.\nShortcuts Tecla Description Click Línea divisora Espacio Cambio de imagen Referencias: http://mesosyn.com/mental8-12.html https://en.wikipedia.org/wiki/Leaning_tower_illusion Jastrol Illution # La ilusión de Jastrow es una ilusión óptica descubierta por el psicólogo estadounidense Joseph Jastrow en 1889. A causa de esta ilusión se percibe como es de mayor tamaño la figura que está más abajo, cuando en realidad ambas tienen el mismo tamaño.\nShortcuts Tecla Description Click sostenido Mostrar tercera ficha Referencias: http://mesosyn.com/mental8-12.html https://en.wikipedia.org/wiki/Jastrow_illusion Poggendorff optical illusion # La ilusión de Poggendorff es un tipo de ilusión óptico-geométrica que implica la percepción errónea de la posición de la prolongación de un segmento inclinado al otro lado de un rectángulo oscuro que lo interrumpe. Debe su nombre a Johann Christian Poggendorff (editor de la revista que publicó las figuras ideadas por Johann Karl Friedrich Zöllner), quien la descubrió en 1860 al observar los dibujos que sirvieron para ilustrar la conocida actualmente como ilusión de Zöllner. La magnitud de la ilusión depende de la configuración del rectángulo que oculta el segmento y de la naturaleza de sus fronteras.\nimage.png\nMuchos estudios detallados de la ilusión, incluyendo la \u0026ldquo;amputación\u0026rdquo; de algunos de sus componentes,​ apuntan a su causa principal: los ángulos agudos en la figura son incorrectamente observados por los espectadores al ser extendidos mentalmente​ a través de la zona oscura, aunque la ilusión disminuye o desaparece cuando el segmento interrumpido es horizontal o vertical. Se sabe que otros factores también están implicados en esta ilusión.​\nShortcuts Tecla Description Slider Opacidad del rectángulo Referencias: http://mesosyn.com/mental8-3.html https://es.wikipedia.org/wiki/Ilusi%C3%B3n_de_Poggendorff http://www.abc-people.com/illusion/illusion-4.htm https://www.newworldencyclopedia.org/entry/Poggendorff_illusion Ejercicios # Exercise\nLet rgb1 and rgb2 be two rgb colors. What rgb1 * rgb2 would mean?\nSabemos que los colores en formato RGB están representados por valores de 0 a 255 en cada uno de los canales (R=Red, G=Green, B=Blue), al ser valores numéricos que implicación su multiplicación.\nPara realizar la multiplicacion de valores de RGB estos primero son normalizados a valores entre 0 a 1, por ejemplo un amarillo (255,255,0) en su forma normalizada seria (1,1,0), para operarlo con otro color como el azul cyan (0, 255, 255), su forma normalizada es (0,1,1), al multiplicar estos colores componente a componente.\n(1, 1, 0)*(0, 1, 1)= (1 * 0, 1 * 1, 0 * 1 )\nDe aqui obtendriamos el color verde que seria (0,1,0) , es decir (0, 255,0)\n"},{"id":1,"href":"/docs/talleres/portal/","title":"Portal","section":"Talleres","content":" Portal # Sketch de Portal # Aqui va el sketch de Portal\n"},{"id":2,"href":"/docs/talleres/shadersExercises/","title":"Shaders Exercises","section":"Talleres","content":" Shaders # ¿Qué es un shader? # Un shader es un programa que se ejecuta en la GPU del ordenador, y genera la salida visual en pantalla dada la información que define una escena 2D o 3D: vértices, colores, texturas, luces, etc. Los shaders no sólo sirven para calcular los niveles de sombreado o iluminación de la escena, sino que son los responsables de todas las etapas del renderizado: desde las transformaciones de la cámara que se aplican sobre la geometría en bruto, hasta la evaluación del color final de cada píxel visible en pantalla.\nPara hacer uso de los shaders es necesario tener el canvas en el modo WEBGL\nEjercicios # Blend Modes Blend Modes (Operaciones con Colores) # Blend Modes es la manera en la que P5 mostrara la combinacion de dos colores. Sketch de Blend (Multiplicacion) # Blend de dos colores haciendo uso de Shader (Multiplicacion) A traves del Fragment shader se realiza la operacion de \\(rgb1 * rgb2\\) blend.js let myShader; let c1, c2; function preload() { myShader = readShader(\u0026#39;/assets/shader/blend.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0. Non Euclidean Espacios No Euclideanos # Con la ayuda de los shader se busca representar objetos que burlar las conceptos geometricos basicos que estamos acustumbrados a ver en la realidad Portal Shaders # Portal Shaders Dos Portales # Portal Shaders Con Múltiples reflejos # Referencias https://visualcomputing.github.io/docs/shaders/non-euclidean_geometry/ https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana Spatial Coherence Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura. Sketch Pixelator (Shader) # pixelator.js \u0026#39;use strict\u0026#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(\u0026#39;/assets/shader/pixelator.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems. Texturing Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \\(0 \\leq X \\leq 1\\) y \\(0 \\leq Y \\leq 1\\) Sketch de UV Texturing # uv. "},{"id":3,"href":"/docs/talleres/shadersExercises/blendModes/","title":"Blend Modes","section":"Shaders Exercises","content":" Blend Modes (Operaciones con Colores) # Blend Modes es la manera en la que P5 mostrara la combinacion de dos colores.\nSketch de Blend (Multiplicacion) # Blend de dos colores haciendo uso de Shader (Multiplicacion) A traves del Fragment shader se realiza la operacion de \\(rgb1 * rgb2\\) blend.js let myShader; let c1, c2; function preload() { myShader = readShader(\u0026#39;/assets/shader/blend.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); shader(myShader); } function draw() { background(0); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } blend.frag precision mediump float; // uniforms are emitted from the sketch // https://p5js.org/reference/#/p5.Shader/setUniform uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 * uMaterial2; } Sketch Blend con Brillo (Multiplicacion) # Blend de dos colores haciendo uso de Shader con valor de brillo (Multiplicacion)\nA traves del Fragment shader se realiza la operacion de \\(brillo * rgb1 * rgb2\\) blendBright.js let myShader; let c1, c2, brightBar; function preload() { myShader = readShader(\u0026#39;/assets/shader/blendBright.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); brightBar = createSlider(0, 1, 0.5, 0.05); brightBar.position(width / 2 - 35, height / 2); brightBar.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); shader(myShader); } function draw() { background(0); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, 1.0); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [1.0, 1.0, 1.0, 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, 1.0); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); myShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); myShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); myShader.setUniform(\u0026#39;brightness\u0026#39;, brightBar.value()); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } blendBright.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = brightness * uMaterial1 * uMaterial2; } Sketch Blend AllModes # Algunos ejemplos de Blend tomando como base dos colores haciendo uso de Shader.\nBlend Add # Este modo de blend suma los valores de los pixeles de una capa con otra. En el caso en que los valores sean superiores a \\( 1 \\) (En el caso de RGB) éste se mostrará en blanco.\nblendAdd.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 + uMaterial2; } Blend Substract # Este modo de blend resta los valores de píxeles de una capa con la otra. En caso de valores negativos, se muestra en negro.\nblendSubstract.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 - uMaterial2; } Blend Divide # Este blend divide los valores de píxeles de una capa con la otra. Es útil para iluminar imágenes en especial con colores grisáceos.\nTambién es útil para eliminar tintes de color, ya que considerando que cualquier valor dividido por sí mismo es igual a \\( 1.0 \\) , es decir, blanco.\nblendDivide.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = uMaterial1 / uMaterial2; } Blend Screen # En este modo de blend los valores de los pixeles en las dos capas se invierten, se multiplican y posteriormente se vuelven a invertir. El resultado es opuesto al blend de multiplicación y como resultado se tendrá un color más brillante (siempre que una de las capas sea más oscura que blanco)\n\\( f(a,b) = 1 - (1 - a)(1 - b) \\) Donde \\( a\\) es la capa base y \\( b\\) es la capa superior.\nEste tipo de blend tiene un resultado conmutativo.\nblendScreen.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = vec4(1.0) - (vec4(1.0)- uMaterial1) * (vec4(1.0) - uMaterial2); } Blend Overlay # El Overlay Blend es una combinación de Multiply blend y Screen blend. En donde: si la capa base es clara, la capa superior se vuelve más clara; si la capa base es oscura, la capa superior se vuelve más oscura; y no se ve afectada la capa superior si la capa base es gris.\n\\( f(a,b)= \\left\\{ \\begin{array}{lcc} 2ab, \u0026amp; si \u0026amp; a \u0026lt; 0.5 \\\\ \\\\ 1 - 2(1 - a)(1 - b), \u0026amp; si \u0026amp; x \\geq 0,5 \\\\ \\end{array} \\right.\\) Donde \\( a\\) es la capa base y \\( b\\) es la capa superior\nblendOverlay.frag precision mediump float; // uniforms are emitted from the sketch // https://p5js.org/reference/#/p5.Shader/setUniform uniform vec4 uMaterial1; uniform vec4 uMaterial2; float rChannel; float gChannel; float bChannel; void main () { // gl_FragColor is a special variable that defines the color of the pixel // https://p5js.org/reference/#/p5.Shader/setUniform if (uMaterial1.x \u0026lt;= 0.5) { rChannel = 2.0*uMaterial1.x*uMaterial2.x; }else{ rChannel = 1.0 - 2.0*(1.0-uMaterial1.x)*(1.0-uMaterial2.x); } if(uMaterial1.y \u0026lt;= 0.5){ gChannel = 2.0*uMaterial1.y*uMaterial2.y; }else{ gChannel = 1.0 - 2.0*(1.0-uMaterial1.y)*(1.0-uMaterial2.y); } if(uMaterial1.z \u0026lt;= 0.5){ bChannel = 2.0*uMaterial1.z*uMaterial2.z; }else{ bChannel = 1.0 - 2.0*(1.0-uMaterial1.z)*(1.0-uMaterial2.z); } gl_FragColor = vec4(rChannel, gChannel, bChannel, 1.0); } Blend SoftLight # Está muy relacionado con Overlay blend y hay múltiples maneras de aplicarlo, en este caso se utiliza la fórmula :\n\\( f_{pegtop}(a,b) = (1 - 2b)a² \u0026#43; 2ba\\) que es una interpolación lineal Multiply blend (para \\( a = 0\\) ) y Screen Blend ( para \\( a = 1 \\) ).\nblendSoftLight.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = (vec4(1.0)-2.0*uMaterial2)*(uMaterial1*uMaterial1)+2.0*uMaterial2*uMaterial1; } Blend Darkness # Sólo se toman los valores de los colores más oscuros, de modo que:\n\\( C = min(A*factor,B) \\) blendDarkness.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = min(uMaterial1, uMaterial2); } Blend Lighten # Sólo se toman los valores de los colores más claros, de modo que:\n\\( C = max(A*factor,B) \\) blendLighten.frag precision mediump float; uniform float brightness; uniform vec4 uMaterial1; uniform vec4 uMaterial2; void main() { gl_FragColor = max(uMaterial1, uMaterial2); } blendAllModes.js let AddShader, SubstractShader, DivideShader, ScreenShader, OverlayShader, SoftLightShader, DarknessShader, LightenShader; let c1, c2; let mode; function preload() { AddShader = readShader(\u0026#39;/assets/shader/blendAdd.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); SubstractShader = readShader(\u0026#39;/assets/shader/blendSubstract.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); DivideShader = readShader(\u0026#39;/assets/shader/blendDivide.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); ScreenShader = readShader(\u0026#39;/assets/shader/blendScreen.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); OverlayShader = readShader(\u0026#39;/assets/shader/blendOverlay.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); SoftLightShader = readShader(\u0026#39;/assets/shader/blendSoftLight.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); DarknessShader = readShader(\u0026#39;/assets/shader/blendDarkness.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); LightenShader = readShader(\u0026#39;/assets/shader/blendLighten.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); } function setup() { createCanvas(600, 600, WEBGL); colorMode(RGB, 1); noStroke(); c1 = createColorPicker(color(0.8, 0.5, 0.3)); c1.position(10, 10); c2 = createColorPicker(color(0.9, 0.1, 0.4)); c2.position(width / 2 + 10, 10); mode = createSelect(); mode.position(10, 40); mode.option(\u0026#39;AddShader\u0026#39;); mode.option(\u0026#39;SubstractShader\u0026#39;); mode.option(\u0026#39;DivideShader\u0026#39;); mode.option(\u0026#39;ScreenShader\u0026#39;); mode.option(\u0026#39;OverlayShader\u0026#39;); mode.option(\u0026#39;SoftLightShader\u0026#39;); mode.option(\u0026#39;DarknessShader\u0026#39;); mode.option(\u0026#39;LightenShader\u0026#39;); mode.selected(\u0026#39;AddShader\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadAShader(mode.value()); } function loadAShader(value) { if (value == \u0026#39;AddShader\u0026#39;) { resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if (value == \u0026#39;SubstractShader\u0026#39;) { resetShader(); shader(SubstractShader); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [-red(c2.color()), -green(c2.color()), -blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); SubstractShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SubstractShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;DivideShader\u0026#39;){ resetShader(); shader(DivideShader); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [1.0, 1.0, 1.0, 1.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c2.color())**2, green(c2.color())**2, blue(c2.color())**2, 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); DivideShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DivideShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;ScreenShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(ScreenShader); ScreenShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); ScreenShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;OverlayShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(OverlayShader); OverlayShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); OverlayShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;SoftLightShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(SoftLightShader); SoftLightShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); SoftLightShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;DarknessShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(DarknessShader); DarknessShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); DarknessShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); }else if(value == \u0026#39;LightenShader\u0026#39;){ resetShader(); shader(AddShader); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [0.0, 0.0, 0.0, 0.0]); beginShape(); vertex(-0.1, 0.1, 0); vertex(-0.1, 0.9, 0); vertex(-0.9, 0.9, 0); vertex(-0.9, 0.1, 0); endShape(); AddShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [0.0, 0.0, 0.0, 0.0]); AddShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.1, 0.1, 0); vertex(0.1, 0.9, 0); vertex(0.9, 0.9, 0); vertex(0.9, 0.1, 0); endShape(); resetShader(); shader(LightenShader); LightenShader.setUniform(\u0026#39;uMaterial1\u0026#39;, [red(c1.color()), green(c1.color()), blue(c1.color()), 1.0]); LightenShader.setUniform(\u0026#39;uMaterial2\u0026#39;, [red(c2.color()), green(c2.color()), blue(c2.color()), 1.0]); beginShape(); vertex(0.45, -0.1, 0); vertex(0.45, -0.9, 0); vertex(-0.45, -0.9, 0); vertex(-0.45, -0.1, 0); endShape(); } } Referencias\nhttps://en.wikipedia.org/wiki/Blend_modes https://p5js.org/reference/#/p5/blendMode https://visualcomputing.github.io/docs/shaders/coloring/\n"},{"id":4,"href":"/docs/talleres/shadersExercises/nonEuclidean/","title":"Non Euclidean","section":"Shaders Exercises","content":" Espacios No Euclideanos # Con la ayuda de los shader se busca representar objetos que burlar las conceptos geometricos basicos que estamos acustumbrados a ver en la realidad\nPortal Shaders # Portal Shaders Dos Portales # Portal Shaders Con Múltiples reflejos # Referencias\nhttps://visualcomputing.github.io/docs/shaders/non-euclidean_geometry/ https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana\n"},{"id":5,"href":"/docs/talleres/shadersExercises/spatialCoherence/","title":"Spatial Coherence","section":"Shaders Exercises","content":" Spatial coherence # El shader que se muestra a continuación utiliza la coherencia espacial para reducir el área de baja resolución a un solo texel. El programa toma una imagen como fuente de textura.\nSketch Pixelator (Shader) # pixelator.js \u0026#39;use strict\u0026#39;; let img1, img2, img3; let mosaic; // ui let resolution; let mode, image_select; function preload() { mosaic = readShader(\u0026#39;/assets/shader/pixelator.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/cheems.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); } function setup() { createCanvas(600, 600, WEBGL); textureMode(NORMAL); noStroke(); resolution = createSlider(1, 200, 30, 1); resolution.position(10, 35); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); image_select = createSelect(); image_select.position(10, 10); image_select.option(\u0026#39;slav cheems\u0026#39;); image_select.option(\u0026#39;dark cheems\u0026#39;); image_select.option(\u0026#39;cheems\u0026#39;); image_select.selected(\u0026#39;slav cheems\u0026#39;); image_select.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); mode = createSelect(); mode.position(120, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;pixelator\u0026#39;); mode.selected(\u0026#39;original\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); // which previous exercise does this code actually solve? /* y v | | (-1,1)| (1,1) (0,1) (1,1) *_____|_____* *__________* | | | | | |_____|_____|__x | texture | | | | | space | *_____|_____* *__________*___ u (-1,-1) (1,-1) (0,0) (1,0) */ // texture coordinates are in the range 0..1 // so we need to map the coordinates to the range -1..1 // to get the correct texture mapping loadPixelImage(); } function loadPixelImage() { if (image_select.value() == \u0026#39;slav cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img1); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img1); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } else if (image_select.value() == \u0026#39;dark cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img2); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img2); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } else if (image_select.value() == \u0026#39;cheems\u0026#39;) { if (mode.value() == \u0026#39;pixelator\u0026#39;) { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img3); mosaic.setUniform(\u0026#39;original\u0026#39;, false); } else { resetShader(); shader(mosaic); mosaic.setUniform(\u0026#39;resolution\u0026#39;, resolution.value()); mosaic.setUniform(\u0026#39;source\u0026#39;, img3); mosaic.setUniform(\u0026#39;original\u0026#39;, true); } } beginShape(); vertex(-1, -1, 0, 0, 1); vertex(1, -1, 0, 1, 1); vertex(1, 1, 0, 1, 0); vertex(-1, 1, 0, 0, 0); endShape(); } pixelator.frag precision mediump float; // source (image or video) is sent by the sketch uniform sampler2D source; // displays original uniform bool original; // target horizontal \u0026amp; vertical resolution uniform float resolution; // interpolated texcoord (same name and type as in vertex shader) // defined as a (normalized) vec2 in [0..1] varying vec2 texcoords2; void main() { if (original) { gl_FragColor = texture2D(source, texcoords2); } else { // define stepCoord to sample the texture source as a 3-step process: // i. define stepCoord as a texcoords2 remapping in [0.0, resolution] ∈ R vec2 stepCoord = texcoords2 * resolution; // ii. remap stepCoord in [0.0, resolution] ∈ Z // see: https://thebookofshaders.com/glossary/?search=floor stepCoord = floor(stepCoord); // iii. remap stepCoord in [0.0, 1.0] ∈ R stepCoord = stepCoord / vec2(resolution); // source texel gl_FragColor = texture2D(source, stepCoord); // ✨ source texels may be used to compute image palette lookup keys, // such as in video \u0026amp; photographic mosaics or ascii art visualizations. } } Sketch Pixelator (Software) # pixelatorSW.js let img1, img2, img3; // creates image variable let resolution, image_select, mode; let size; // element size let loadOnce = false; function preload() { img1 = loadImage(\u0026#39;/assets/image/slav_cheems.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/dark_cheems.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/cheems.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); } function setup() { createCanvas(600, 600); resolution = createSlider(1, 200, 30, 1); resolution.position(10, 35); resolution.style(\u0026#39;width\u0026#39;, \u0026#39;120px\u0026#39;); image_select = createSelect(); image_select.position(10, 10); image_select.option(\u0026#39;slav cheems\u0026#39;); image_select.option(\u0026#39;dark cheems\u0026#39;); image_select.option(\u0026#39;cheems\u0026#39;); image_select.selected(\u0026#39;slav cheems\u0026#39;); image_select.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); mode = createSelect(); mode.position(120, 10); mode.option(\u0026#39;original\u0026#39;); mode.option(\u0026#39;pixelator\u0026#39;); mode.selected(\u0026#39;original\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); size = floor(height / resolution.value()); loadPixelImage(); } function loadPixelImage() { if (image_select.value() == \u0026#39;slav cheems\u0026#39;) { image(img1, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } else if (image_select.value() == \u0026#39;dark cheems\u0026#39;) { image(img2, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } else if (image_select.value() == \u0026#39;cheems\u0026#39;) { image(img3, 0, 0, width, height); if (mode.value() == \u0026#39;pixelator\u0026#39;) { pixelator(); } } } function pixelator() { loadPixels(); for (var y = 0; y \u0026lt; height; y++) { for (var x = 0; x \u0026lt; width; x++) { var index = (x + y * width) * 4; var r = pixels[index + 0]; var g = pixels[index + 1]; var b = pixels[index + 2]; var a = pixels[index + 3]; noStroke(); fill(r, g, b, a); rect(x, y, size, size); x = x + size - 1 } y = y + size - 1 } } Referencias\nhttps://visualcomputing.github.io/docs/shaders/spatial_coherence/\n"},{"id":6,"href":"/docs/talleres/shadersExercises/texturing/","title":"Texturing","section":"Shaders Exercises","content":" Texturing (Uso de texturas a traves de Shaders) # Como hemos aprendido en el transcurso de este capitulo, sabemos que p5 para renderizar en general hace uso de un shader general, tambien hemos visto que es posible tener un acercamiento hacia la texturizacion de objetos haciendo uso de shaders programados manualmente, en esta seccion mostraremos nuestro acercamiento inicial hacia el texturado con shaders entiendo el espacio de textura que esta dado por el espacio UV, que lo entendemos como un espacio normalizado donde las coordenadas \\(0 \\leq X \\leq 1\\) y \\(0 \\leq Y \\leq 1\\) Sketch de UV Texturing # uv.js let uvShader; function preload() { // Define geometry directly in clip space (i.e., matrices: Tree.NONE). // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(\u0026#39;/sketches/shaders/uv.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { // shaders require WEBGL mode to work createCanvas(300, 300, WEBGL); noStroke(); // see: https://p5js.org/reference/#/p5/shader shader(uvShader); // https://p5js.org/reference/#/p5/textureMode // best and simplest is to just always used NORMAL textureMode(NORMAL); } function draw() { background(0); /* clip-space quad shape, i.e., both x and y vertex coordinates ∈ [-1..1] since textureMode is NORMAL, texture coordinates ∈ [-1..1] see: https://p5js.org/reference/#/p5/beginShape https://p5js.org/reference/#/p5/vertex y v | | (-1,1)| (1,1) (0,1) (1,1) *_____|_____* *__________* | | | | | |_____|_____|__x | texture | | | | | space | *_____|_____* *__________*___ u (-1,-1) (1,-1) (0,0) (1,0) */ beginShape(); vertex(-1, -1, 0, 0, 0); vertex( 1, -1, 0, 1, 0); vertex( 1, 1, 0, 1, 1); vertex(-1, 1, 0, 0, 1); endShape(); // ✨ it\u0026#39;s worth noting (not mentioned in the p5 api docs though) // that quad (https://p5js.org/reference/#/p5/quad) also adds the // texture coords to each of its vertices. Hence: // quad(-1, -1, 1, -1, 1, 1, -1, 1); // produce the same results as the above beginShape / endShape } uv.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 0.0, 1.0); } Sketch de UV Texturing (Coordenadas Inversas) # uv.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.x, 1.0 - texcoords2.y, 0.0, 1.0); } Sketch de UV Texturing (Agregando Color Azul) # uvBlueX.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.x, 1.0); } uvBlueY.frag precision mediump float; // the texture coordinates varying was defined in // the vertex shader by treegl readShader() // open your console and \u0026amp; see! varying vec2 texcoords2; void main() { // glsl swizzling is both handy and elegant // see: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.y, 1.0); } Sketch de UV Screen # uv_screen.js let easycam; let uvShader; let opacity; let mode; function preload() { // Define geometry in world space (i.e., matrices: Tree.pmvMatrix). // The projection and modelview matrices may be emitted separately // (i.e., matrices: Tree.pMatrix | Tree.mvMatrix), which actually // leads to the same gl_Position result. // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(\u0026#39;/assets/shader/uv_alpha.frag\u0026#39;, { matrices: Tree.pmvMatrix, varyings: Tree.texcoords2 }); } function setup() { createCanvas(600, 600, WEBGL); // easycam stuff let state = { distance: 250, // scalar center: [0, 0, 0], // vector rotation: [0, 0, 0, 1], // quaternion }; easycam = createEasyCam(); easycam.state_reset = state; // state to use on reset (double-click/tap) easycam.setState(state, 2000); // now animate to that state textureMode(NORMAL); opacity = createSlider(0, 1, 0.5, 0.01); opacity.position(10, 25); opacity.style(\u0026#39;width\u0026#39;, \u0026#39;280px\u0026#39;); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;quad\u0026#39;); mode.option(\u0026#39;ellipse\u0026#39;); mode.option(\u0026#39;triangleUP\u0026#39;); mode.option(\u0026#39;triangleDOWN\u0026#39;); mode.selected(\u0026#39;uvShaderBlueX\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(200); // reset shader so that the default shader is used to render the 3D scene resetShader(); // world space scene axes(); grid(); translate(0, -70); rotateY(0.5); fill(color(255, 0, 255, 125)); box(30, 50); translate(70, 70); fill(color(0, 255, 255, 125)); sphere(30, 50); // use custom shader shader(uvShader); uvShader.setUniform(\u0026#39;opacity\u0026#39;, opacity.value()); // screen-space quad (i.e., x ∈ [0..width] and y ∈ [0..height]) // see: https://github.com/VisualComputing/p5.treegl#heads-up-display loadFigure(mode.value()); } function mouseWheel(event) { //comment to enable page scrolling return false; } function loadFigure(value) { if (value == \u0026#39;quad\u0026#39;) { beginHUD(); noStroke(); quad(0, 0, width, 0, width, height, 0, height); endHUD(); } else if (value == \u0026#39;ellipse\u0026#39;) { beginHUD(); noStroke(); ellipse(width / 2, height / 2, width, height); endHUD() } else if (value == \u0026#39;triangleUP\u0026#39;) { beginHUD(); noStroke(); triangle(0, 0, width, 0, width, height); endHUD(); } else if (value == \u0026#39;triangleDOWN\u0026#39;) { beginHUD(); noStroke(); triangle(0, 0, 0, height, width, height); endHUD(); } } uv_alpha.frag precision mediump float; varying vec2 texcoords2; varying vec4 color4; // uniform is sent by the sketch uniform float opacity; void main() { gl_FragColor = vec4(texcoords2.xy, 1.0 - texcoords2.x, opacity); } Sketch de Luma y Aritmetic Mean # luma_mena.js let lumaShader, meanShader; let img1, img2; let grey_scale, mode; function preload() { lumaShader = readShader(\u0026#39;/assets/shader/luma.frag\u0026#39;, { varyings: Tree.texcoords2 }); meanShader = readShader(\u0026#39;/assets/shader/mean.frag\u0026#39;, { varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/fire.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/fire2.jpg\u0026#39;); } function setup() { createCanvas(600, 600, WEBGL); noStroke(); textureMode(NORMAL); shader(lumaShader); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;fire 1\u0026#39;); mode.option(\u0026#39;fire 2\u0026#39;); mode.selected(\u0026#39;fire 1\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); grey_scale = createSelect(); grey_scale.position(60, 10); grey_scale.option(\u0026#39;original\u0026#39;); grey_scale.option(\u0026#39;luma\u0026#39;); grey_scale.option(\u0026#39;average\u0026#39;); grey_scale.selected(\u0026#39;original\u0026#39;); grey_scale.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadShaderImage(); } function loadShaderImage() { if (mode.value() == \u0026#39;fire 1\u0026#39;) { if (grey_scale.value() == \u0026#39;luma\u0026#39;) { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img1); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else if (grey_scale.value() == \u0026#39;average\u0026#39;) { resetShader(); shader(meanShader); meanShader.setUniform(\u0026#39;texture\u0026#39;, img1); meanShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img1); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;fire 2\u0026#39;) { if (grey_scale.value() == \u0026#39;luma\u0026#39;) { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img2); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else if (grey_scale.value() == \u0026#39;average\u0026#39;) { resetShader(); shader(meanShader); meanShader.setUniform(\u0026#39;texture\u0026#39;, img2); meanShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(lumaShader); lumaShader.setUniform(\u0026#39;texture\u0026#39;, img2); lumaShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } luma.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; // returns luma of given texel float luma(vec3 texel) { return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(luma(texel.rgb))), 1.0) : texel; } mean.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; // returns luma of given texel float luma(vec3 texel) { return (texel.r + texel.g + texel.b)/3.0; } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(luma(texel.rgb))), 1.0) : texel; } Sketch de HSV # hsv.js let hsvShader; let img1, img2, img3, img4, img5; let grey_scale, mode; function preload() { hsvShader = readShader(\u0026#39;/assets/shader/hsv.frag\u0026#39;, { varyings: Tree.texcoords2 }); img1 = loadImage(\u0026#39;/assets/image/landscape1.jpg\u0026#39;); img2 = loadImage(\u0026#39;/assets/image/landscape2.jpg\u0026#39;); img3 = loadImage(\u0026#39;/assets/image/landscape3.jpg\u0026#39;); img4 = loadImage(\u0026#39;/assets/image/landscape4.jpg\u0026#39;); img5 = loadImage(\u0026#39;/assets/image/landscape5.jpg\u0026#39;); img1.resize(0, height); img2.resize(0, height); img3.resize(0, height); img4.resize(0, height); img5.resize(0, height); } function setup() { createCanvas(600, 600, WEBGL); noStroke(); textureMode(NORMAL); mode = createSelect(); mode.position(10, 10); mode.option(\u0026#39;landscape 1\u0026#39;); mode.option(\u0026#39;landscape 2\u0026#39;); mode.option(\u0026#39;landscape 3\u0026#39;); mode.option(\u0026#39;landscape 4\u0026#39;); mode.option(\u0026#39;landscape 5\u0026#39;); mode.selected(\u0026#39;landscape 1\u0026#39;); mode.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); grey_scale = createSelect(); grey_scale.position(110, 10); grey_scale.option(\u0026#39;original\u0026#39;); grey_scale.option(\u0026#39;hsv\u0026#39;); grey_scale.selected(\u0026#39;original\u0026#39;); grey_scale.changed(() =\u0026gt; { console.log(\u0026#34;Change\u0026#34;); }); } function draw() { background(0); loadShaderImage(); } function loadShaderImage() { if (mode.value() == \u0026#39;landscape 1\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img1); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img1); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 2\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img2); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img2); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 3\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img3); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img3); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 4\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img4); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img4); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } else if (mode.value() == \u0026#39;landscape 5\u0026#39;) { if (grey_scale.value() == \u0026#39;hsv\u0026#39;) { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img5); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, true); } else { resetShader(); shader(hsvShader); hsvShader.setUniform(\u0026#39;texture\u0026#39;, img5); hsvShader.setUniform(\u0026#39;grey_scale\u0026#39;, false); } } quad(-width / 2, -height / 2, width / 2, -height / 2, width / 2, height / 2, -width / 2, height / 2); } hsv.frag precision mediump float; // uniforms are defined and sent by the sketch uniform bool grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; float modI(float a,float b) { float m=a-floor((a+0.5)/b)*b; return floor(m+0.5); } vec3 hsv(vec3 c) { float rValor = c.r; float gValor = c.g; float bValor = c.b; float maximo = max(max(rValor, gValor), bValor); float minimo = min(max(rValor, gValor), bValor); float h = 0.0; if(maximo == rValor){ h = 60.0 * modI((gValor - bValor)/(maximo - minimo), 6.0); }else if (maximo == gValor){ h = 60.0 * (((bValor - rValor) / (maximo - minimo)) + 2.0); }else{ h = 60.0 * (((rValor - gValor) / (maximo - minimo)) + 4.0); } float s = 0.0; if(maximo != 0.0){ s = (maximo - minimo) / maximo; }else{ s = 0.0; } float v = maximo; return vec3(h, s, v); } void main() { // texture2D(texture, texcoords2) samples texture at texcoords2 // and returns the normalized texel color vec4 texel = texture2D(texture, texcoords2); gl_FragColor = grey_scale ? vec4((vec3(hsv(texel.rgb))), 1.0) : texel; } Referencias\nhttps://visualcomputing.github.io/docs/shaders/texturing/ https://vcwork.github.io/project/docs/Entrega3/parte1/ https://en.wikipedia.org/wiki/HSL_and_HSV\n"},{"id":7,"href":"/posts/blog/","title":"Blog","section":"Blog","content":" Intregantes # Brayan David Leon Sanabria # Juan Sebastian Silva Castillo # "}]